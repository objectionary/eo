+architect yegor256@gmail.com
+home https://github.com/objectionary/eo
+package org.eolang.txt
+rt jvm org.eolang:eo-runtime:0.0.0
+rt node eo2js-runtime:0.0.0
+version 0.0.0
+spdx SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
+spdx SPDX-License-Identifier: MIT
+unlint redundant-object:55
+unlint redundant-object:63
+unlint redundant-object:89
+unlint redundant-object:90
+unlint redundant-object:92
+unlint redundant-object:99

# Regular expression in Perl format.
# Here `expression` is a string pattern.
# It starts and ends with slash (e.g. "/(your-expression)/"),
# Also it can be specified by the flag option,
# e.g.
# ```
# (`QQ.txt.regex "/(word)/i").compiled.matches "WORD"
# ```
# Supported flags:
# /d - Enables Unix lines mode.
# /i - Enables case-insensitive matching.
# /x - Permits whitespace and comments in pattern.
# /m - Enables multiline mode.
# /s - Enables dotall mode.
# /u - Enables Unicode-aware case folding.
[expression] > regex
  # Compile regular expression into pattern.
  # ```
  # (regex "/[a-z]+/").compiled.matches "hello"
  # (regex "/[a-z]+").matches "hello"
  # ```
  # The two lines of code above works the same, but the usage of `.compiled`
  # allows you utilize object cache in order to avoid double pattern compilation.
  # ```
  # regex "/[a-z]+/" > ptn1
  # ptn1.matches "hey"                  # compiles regex
  # ptn1.matches "hello"                # recompiles regex again
  #
  # (regex "/[a-z]+/").compiled > ptn2
  # ptn2.matches "hey"                  # compiles regex
  # ptn2.matches "hello"                # doesn't recompile regex
  # ```
  # Returns `org.eolang.txt.regex.pattern` object.
  [] > @ ?

  # Regular expression compiled into pattern.
  # Here `serialized` is `bytes` which represents serialized structure in memory
  # that is built after compilation.
  [serialized] > pattern
    pattern serialized > compiled

    # Returns `true` of given `txt` matches against
    # the provided regular expression pattern.
    (match txt).next.exists > [txt] > matches

    # Creates a `matcher` that will match the given input against the pattern.
    [txt] > match
      matched-from-index 1 0 > next

      # Get `position`-th block matched from `start` position.
      # If string subsequence is found - returns `org.eolang.txt.regex.pattern.match.matched`
      # object, returns `org.eolang.txt.regex.pattern.match.not-matched` otherwise.
      #
      # Attention! The object is for internal usage only, please
      # don't use the object programmatically outside of `regex` object.
      [position start] > matched-from-index ?

      # Block matched the pattern.
      # Here:
      # - `position`      - sequence number of matched block,
      # - `start`         - matched region start index.
      #   If equal to -1 - block was not matched
      # - `from`          - index where matched string sequence starts
      # - `to`            - index where matched string sequence ends
      # - `groups`        - tuple of identified matched groups
      #
      # The block provides the next API to work with matched string subsequence:
      # - `groups-count`  - to get amount of matched groups
      # - `exists`        - to check if matched block is not empty
      # - `next`          - to get next matched block
      # - `text`          - to get matched subsequence as `string`
      # - `group {index}` - to get string subsequence captured by `index`-th group.
      # @todo #4533:60min Enable disabled tests with regexes.
      #  Currently we disabled the following 7 tests: `tests-sanitizes-windows-path-with-regex`,
      #  `tests-replaces-windows-path-with-slash`, `tests-replaces-digits-with-string`,
      #  `tests-regex-contains-valid-groups-on-each-matched-block`,
      #  `tests-replaces-slashes-to-windows-separator`,
      #  `tests-regex-returns-valid-second-matched-block`,
      #  `tests-normalizes-win32-path-with-replacing-slashes`, `tests-walks-recursively`,
      #  since idempotency attribute `xiðŸŒµ` is not available in runtime for Phi.take("xiðŸŒµ").
      #  We need to correctly model it in runtime first, then enable tests.
      [position start from to groups] > matched
        groups.length > groups-count
        start.gte 0 > exists
        if. > next'
          exists
          matched-from-index
            position.plus 1
            to
          error "Matched block does not exist, can't get next"
        if. > text
          exists
          group 0
          error "Matched block does not exist, can't get text"

        # Returns the string subsequence captured by the group
        # by `index` during the `match` operation.
        groups.at index > [index] > group

      # Block which does not match the provided pattern.
      # Decorates `matched` block with corresponding `error`s.
      [position] > not-matched
        matched > @
          position
          -1
          error "Matched block does not exist, can't get 'from' position"
          error "Matched block does not exist, can't get 'to' position"
          error "Matched block does not exist, can't get groups"

  # Tests that regex pattern matches against text containing lowercase letters.
  [] +> tests-matches-regex-against-the-pattern
    (regex "/[a-z]+/").compiled.matches "hello" > @

  # Tests that regex pattern does not match text containing only digits.
  [] +> tests-does-not-matches-regex-against-the-pattern
    ((regex "/[a-z]+/").compiled.matches "123").not > @

  # Tests that matched block returns correct start, from, and to positions.
  [] +> tests-matched-sequence-has-right-border-indexes
    and. > @
      0.eq n.start
      and.
        1.eq n.from
        6.eq n.to
    ((regex "/[a-z]+/").match "!hello!").next > n

  # Tests that matched block returns the correct text substring.
  [] +> tests-regex-returns-valid-matched-string-sequence
    ((regex "/[a-z]+/").match "!hello!").next.text.eq "hello" > @

  # Tests that regex can find multiple matches with correct positions and text.
  [] > tests-regex-returns-valid-second-matched-block
    and. > @
      and.
        and.
          and.
            second.text.eq "world"
            second.position.eq 2
          second.start.eq 6
        second.from.eq 7
      second.to.eq 12
    ((regex "/[a-z]+/").match "!hello!world!").next.next > second

  # Tests that accessing next on non-existent match throws error.
  [] +> throws-on-getting-next-on-not-matched-block
    ((regex "/[a-z]+/").match "123").next.next > @

  # Tests that accessing from position on non-matched block throws error.
  [] +> throws-on-getting-from-position-on-not-matched-block
    ((regex "/[a-z]+/").match "123").next.from > @

  # Tests that accessing to position on non-matched block throws error.
  [] +> throws-on-getting-to-position-on-not-matched-block
    ((regex "/[a-z]+/").match "123").next.to > @

  # Tests that accessing groups count on non-matched block throws error.
  [] +> throws-on-getting-groups-count-on-not-matched-block
    ((regex "/[a-z]+/").match "123").next.groups-count > @

  # Tests that accessing groups on non-matched block throws error.
  [] +> throws-on-getting-groups-on-not-matched-block
    ((regex "/[a-z]+/").match "123").next.groups > @

  # Tests that accessing specific group on non-matched block throws error.
  [] +> throws-on-getting-specified-group-on-not-matched-block
    ((regex "/[a-z]+/").match "123").next.group 1 > @

  # Tests that accessing text on non-matched block throws error.
  [] +> throws-on-getting-text-on-not-matched-block
    ((regex "/[a-z]+/").match "123").next.text > @

  # Tests that regex with dotall flag matches text containing newlines.
  [] +> tests-regex-matches-dotall-option
    regex
      "/(.*)/s"
    .compiled
    .matches > @
      "too \\n many \\n line \\n Feed\\n"

  # Tests that regex with case-insensitive flag matches mixed case text.
  [] +> tests-regex-matches-with-case-insensitive-option
    regex
      "/(string)/i"
    .compiled
    .matches > @
      "StRiNg"

  # Tests that regex with multiline flag matches across multiple lines.
  [] +> tests-regex-matches-with-multiline-option
    regex
      "/(^([0-9]+).*)/m"
    .compiled
    .matches > @
      "1 bottle of water on the wall. \\n1 bottle of water."

  # Tests that regex pattern with digit and escape sequences matches text.
  [] +> tests-regex-matches-entire-pattern
    regex
      "/[0-9]/\\d+/"
    .compiled
    .matches > @
      "2/75"

  # Tests that regex with unix lines flag matches text with line terminators.
  [] +> tests-regex-matches-with-regex-unix-lines
    regex
      "/(.+)/d"
    .compiled
    .matches > @
      "A\\r\\nB\\rC\\nD"

  # Tests that regex with case-insensitive flag matches uppercase text.
  [] +> tests-regex-matches-with-regex-case-insensitive-and-caps
    regex
      "/(word)/i"
    .compiled
    .matches > @
      "WORD"

  # Tests that regex with extended flag ignores comments in pattern.
  [] +> tests-regex-ignores-comments-in-string
    regex
      "/(\\d) #ignore this comment/x"
    .compiled
    .matches > @
      "4"

  # Tests that regex with unicode and case-insensitive flags matches Unicode text.
  [] +> tests-regex-matches-with-unicode-case-and-insensitive
    regex
      "/(yildirim)/ui"
    .compiled
    .matches > @
      "YÄ±ldÄ±rÄ±m"

  # Tests that regex compilation throws error when missing opening slash.
  [] +> throws-on-missing-first-slash-in-regex
    (regex "(.)+").compiled > @

  # Tests that regex with capturing groups returns correct group count and content.
  [] > tests-regex-contains-valid-groups-on-each-matched-block
    and. > @
      and.
        and.
          first.groups-count.eq 3
          (first.group 1).eq "hello"
        (first.group 2).eq "1"
      and.
        and.
          second.groups-count.eq 3
          (second.group 1).eq "world"
        (second.group 2).eq "2"
    ((regex "/([a-z]+)([1-9]{1})/").compiled.match "!hello1!world2").next > first
    first.next > second
