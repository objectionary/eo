+alias org.eolang.ss.bytes-as-array
+alias org.eolang.ss.list
+alias org.eolang.tt.regex
+alias org.eolang.tt.sprintf
+alias org.eolang.tt.slice
+architect yegor256@gmail.com
+home https://github.com/objectionary/eo
+package org.eolang.tt
+version 0.0.0
+spdx SPDX-FileCopyrightText: Copyright (c) 2016-2025 Objectionary.com
+spdx SPDX-License-Identifier: MIT
+unlint redundant-object:24
+unlint redundant-object:27
+unlint redundant-object:29
+unlint redundant-object:31
+unlint redundant-object:292

# Text.
# A sequence of characters representing words, sentences, or data.
[origin] > text
  origin > @
  # Check that all signs in string are letters.
  # Works only for english letters.
  (regex "/^[a-zA-Z]+$/").matches origin > is-alpha
  # Check that all signs in string are ASCII characters.
  (regex "/^[\\x00-\\x7F]*$/").matches origin > is-ascii

  # Returns a `tuple` of `strings`, separated by a given `delimiter`.
  [delimiter] > split
    if. > @
      len.eq 0
      *
      rec-split * 0 0
    delimiter > delim!
    origin > self-as-bytes!
    self-as-bytes.size > len!

    [accum start current] > rec-split
      if. > @
        len.eq current
        accum.with > with-substr
          string
            slice
              self-as-bytes
              start
              current.minus start
        if.
          delim.eq
            slice self-as-bytes current 1
          rec-split
            with-substr
            (current.plus 1).as-number
            (current.plus 1).as-number
          rec-split
            accum
            start
            (current.plus 1).as-number

  # Returns a `tuple` of `strings` split by `delimiter` with a maximum of `limit` parts.
  # The last element contains the remainder of the string after splitting.
  # If `limit` < 1, an error is returned.
  [delimiter limit] > nsplit
    if. > @
      1.gt limit
      error
        sprintf
          "Invalid limit %d for nsplit, must be at least 1"
          * limit
      if.
        origin.size.eq 0
        *
        if.
          1.eq limit
          * origin
          rec-nsplit * 0 0 0

    [accum start current splits-made] > rec-nsplit
      if. > @
        origin.size.eq current
        accum.with > with-substr
          string
            slice
              origin
              start
              current.minus start
        if.
          and.
            delimiter.eq
              slice origin current 1
            (number splits-made).lt
              (number limit).minus 1
          rec-nsplit
            with-substr
            (current.plus 1).as-number
            (current.plus 1).as-number
            (splits-made.plus 1).as-number
          rec-nsplit
            accum
            start
            (current.plus 1).as-number
            splits-made

  # Returns concatenation of all `other` strings.
  # Here `others` must be a `tuple` of `strings`.
  [others] > chained
    if. > @
      0.eq others.length
      ^
      text
        string
          reduced.
            list others
            origin.as-bytes
            accum.concat str.as-bytes > [accum str]

  # Tests specific functionality chained method concatenates text with multiple other strings.
  [] +> tests-chains-with-other-strings
    eq. > @
      "Hello, world!"
      chained.
        text "Hello"
        *
          ", "
          "world"
          "!"

  # Tests specific functionality chained method returns original text when no strings provided.
  [] +> tests-returns-same-text-on-chaining-with-no-strings
    eq. > @
      "Some"
      chained.
        text "Some"
        *

  # Tests that split method divides text into parts using dash delimiter.
  [] +> tests-splits-text-by-dash
    eq. > @
      list
        (text "a-b-c").split "-"
      * "a" "b" "c"

  # Tests that split method handles empty strings between delimiters.
  [] +> tests-splits-text-with-empty-strings
    eq. > @
      list
        (text "-a-b-").split "-"
      * "" "a" "b" ""

  # Tests that split returns proper string objects with correct length.
  [] +> tests-splits-and-returns-strings
    eq. > @
      length.
        at.
          split.
            text "hello world!"
            " "
          1
      6

  # Tests that nsplit splits with limit 2 correctly.
  [] +> tests-nsplit-with-limit-two
    eq. > @
      list
        nsplit.
          text "Cookie: a=1; b=2"
          " "
          2
      * "Cookie:" "a=1; b=2"

  # Tests that nsplit splits with limit 2 on dashes.
  [] +> tests-nsplit-with-dashes-limit-two
    eq. > @
      list
        nsplit.
          text "a-b-c-d"
          "-"
          2
      * "a" "b-c-d"

  # Tests that nsplit with limit 1 returns entire string.
  [] +> tests-nsplit-with-limit-one
    eq. > @
      list
        nsplit.
          text "a-b-c"
          "-"
          1
      * "a-b-c"

  # Tests that nsplit with limit greater than splits behaves like split.
  [] +> tests-nsplit-with-high-limit
    eq. > @
      list
        nsplit.
          text "a-b-c"
          "-"
          10
      * "a" "b" "c"

  # Tests that nsplit throws error with limit 0.
  [] +> throws-on-nsplit-with-limit-zero
    nsplit. > @
      text "text"
      "-"
      0

  # Tests that nsplit throws error with negative limit.
  [] +> throws-on-nsplit-with-negative-limit
    nsplit. > @
      text "text"
      "-"
      -1

  # Tests that nsplit handles empty strings between delimiters.
  [] +> tests-nsplit-with-empty-strings
    eq. > @
      list
        nsplit.
          text "-a-b-c"
          "-"
          3
      * "" "a" "b-c"

  # Tests that is-ascii returns true for text containing only ASCII characters.
  [] +> tests-checks-if-text-is-ascii
    is-ascii. > @
      text
        "H311oW"

  # Tests that is-ascii returns false for text containing emoji characters.
  [] +> tests-checks-if-emoji-is-not-ascii
    not. > @
      is-ascii.
        text
          "ğŸŒµ"

  # Tests that is-ascii returns true for text containing only numeric digits.
  [] +> tests-checks-if-string-of-numbers-is-ascii
    is-ascii. > @
      text
        "123"

  # Tests specific functionality is-alpha returns true for text containing only letters.
  [] +> tests-checks-if-simple-text-is-alpha
    is-alpha. > @
      text
        "eEo"

  # Tests that is-alpha returns false for text containing numbers.
  [] +> tests-checks-if-text-with-number-is-not-alpha
    not. > @
      is-alpha.
        text
          "ab3d"

  # Tests that is-alpha returns false for text containing special characters.
  [] +> tests-checks-if-text-with-dashes-is-not-alpha
    not. > @
      is-alpha.
        text
          "-w-"
