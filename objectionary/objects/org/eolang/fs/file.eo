+alias org.eolang.txt.sprintf
+architect yegor256@gmail.com
+home https://github.com/objectionary/eo
+package org.eolang.fs
+rt jvm org.eolang:eo-runtime:0.55.0
+rt node eo2js-runtime:0.0.0
+version 0.55.0
+spdx SPDX-FileCopyrightText Copyright (c) 2016-2025 Objectionary.com
+spdx SPDX-License-Identifier: MIT
+unlint rt-without-atoms
+unlint empty-object
+unlint wrong-sprintf-arguments

# The file object in the filesystem.
[path] > file
  $ > as-file
  $.path > @
  # Convert the `file` to the `path`.
  (QQ.fs.path path).determined > as-path

  # Returns `org.eolang.true` if current file is a directory, returns `org.eolang.false` otherwise.
  [] > is-directory ?

  # Returns `org.eolang.true` if file with current `path` exists in filesystem.
  [] > exists ?

  # If current file exists - returns the file.
  # If current file does not exist - create an empty file
  # in filesystem and returns it.
  [] > touched
    as-file. > @
      if.
        exists
        ^
        seq *
          touch
          ^

    # Creates new empty file and returns `org.eolang.true`.
    #
    # Attention! The object is for internal usage only, please
    # don't use the object programmatically outside of `file` object.
    [] > touch ?

  # If current file exists - deletes it and returns it.
  # If current file does not exist - just returns it.
  [] > deleted
    as-file. > @
      if.
        exists
        seq *
          delete
          ^
        ^

    # Deletes the file and returns `org.eolang.true`.
    #
    # Attention! The object is for internal usage only, please
    # don't use the object programmatically outside of `file` object.
    [] > delete ?

  # Gets the file size in bytes and returns it as `org.eolang.number`.
  [] > size ?

  # Move current file to `target`, making and returning a new `file` from it.
  [target] > moved
    as-file. > @
      file move

    # Tries to move file from `^.path` to `target`
    # and returns path of moved file as `org.eolang.string`.
    # Returns `org.eolang.error` is failed to move the file.
    #
    # Attention! The object is for internal usage only, please
    # don't use the object programmatically outside of `file` object.
    [] > move ?

  # Opens the file.
  #
  # The first argument `mode` defines the operations that are allowed on the file
  # and how these operations are performed.
  #
  # The access mode can be:
  # |------|-------------|----------------------|-------------------|----------------------|
  # | Mode | Description | File Existence       | Init pointer pos  | Content Handling     |
  # |======|=============|======================|===================|======================|
  # | "r"  | Read only   | Must exist           | Beginning         | No changes           |
  # |------|-------------|----------------------|-------------------|----------------------|
  # | "w"  | Write only  | Created if not exist | Beginning         | Truncated if exists, |
  # |      |             |                      |                   | created if not       |
  # |------|-------------|----------------------|-------------------|----------------------|
  # | "a"  | Append only | Created if not exist | End               | No truncation,       |
  # |      |             |                      |                   | created if not       |
  # |------|-------------|----------------------|-------------------|----------------------|
  # | "r+" | Read/Write  | Must exist           | Beginning         | No changes           |
  # |------|-------------|----------------------|-------------------|----------------------|
  # | "w+" | Write/Read  | Created if not exist | Beginning         | Truncated if exists, |
  # |      |             |                      |                   | created if not       |
  # |------|-------------|----------------------|-------------------|----------------------|
  # | "a+" | Read/Append | Created if not exist | End (for writing) | No truncation,       |
  # |      |             |                      |                   | created if not       |
  # |------|-------------|----------------------|-------------------|----------------------|
  #
  # The second argument `scope` is the scope where file is available as input
  # (the `read` object is available) or output (the `write` object is available).
  #
  # When `file.open` is dataized - it opens file stream, dataizes the `scope`,
  # closes the file stream and returns an original file object.
  [mode scope] > open
    mode > access!
    (access.eq "r").as-bool > read
    (access.eq "w").as-bool > write
    (access.eq "a").as-bool > append
    (access.eq "r+").as-bool > read-write
    (access.eq "w+").as-bool > write-read
    (access.eq "a+").as-bool > read-append
    as-bool. > can-read
      or.
        read.or read-write
        write-read.or read-append
    as-bool. > can-write
      or.
        or.
          write.or read-write
          write-read.or read-append
        append
    as-bool. > must-exists
      read.or read-write
    as-bool. > truncate
      write.or write-read
    as-file. > @
      if.
        can-read.not.and can-write.not
        error "Wrong access mod. Only next modes are available: 'r', 'w', 'a', 'r+', 'w+', 'a+'"
        if.
          exists.not
          if.
            must-exists
            error
              sprintf
                "File must exist for given access mod: '%s'"
                * access
            seq *
              touched.touch
              process-file
              ^
          if.
            truncate
            seq *
              deleted.delete
              touched.touch
              process-file
              ^
            seq *
              process-file
              ^

    # Process current file in the provided scope.
    #
    # Here file stream is open, then the stream is passed to `scope`,
    # then given `scope` is dataized and stream is closed.
    # Returns `org.eolang.true` if there are no errors occurred while `scope`
    # dataization, returns `org.eolang.error` otherwise.
    #
    # The object is stream-safe, which means that stream is closed anyway,
    # even if errors are occurred while `scope` dataization.
    #
    # Attention! The object is for internal usage only, please
    # don't use the object programmatically outside of the `file` object.
    [] > process-file ?

    # File stream.
    # The objects provides an API for using file as input or output.
    [] > file-stream
      # Read `size` amount of bytes from file input stream.
      # Returns new instance of `input-block` with `buffer` read from file, or
      # returns `org.eolang.error` if access mode does not allow reading operations.
      [size] > read
        ((input-block --).read size).this > @

        # File input block
        #
        # Attention! The object is for internal usage only, please
        # don't use the object programmatically outside of `file` object.
        [buffer] > input-block
          $ > this
          buffer > @

          # Read `size` amount of bytes from file input stream.
          # Returns new instance of `input-block` with `buffer` read from file, or
          # returns `org.eolang.error` if provided access mode does not allow reading operations.
          [size] > read
            ^.^.read-bytes size > read-bytes!
            this. > @
              if.
                can-read.not
                [] >>
                  $ > this
                  error > @
                    sprintf
                      "Can't read from file with provided access mode '%s'"
                      * access
                seq *
                  read-bytes
                  input-block read-bytes

        # Bytes, as `org.eolang.bytes`, read from file input stream.
        #
        # Attention! The object is for internal usage only, please
        # don't use the object programmatically outside of `file` object.
        [size] > read-bytes ?

      # Write given `buffer` to file output stream.
      # Here `buffer` is either sequence of bytes or and object that can be
      # dataized via `as-bytes` object.
      # Returns new instance of `output-block` ready to write again, or
      # returns an error if provided access mode does not allow writing operations.
      [buffer] > write
        (output-block.write buffer).this > @

        # File output block.
        #
        # Attention! The object is for internal usage only, please
        # don't use the object programmatically outside of `file` object.
        [] > output-block
          $ > this
          true > @

          # Write given `buffer` to file output stream.
          # Here `buffer` is either sequence of bytes or and object that can be
          # dataized via `as-bytes` object.
          # Returns new instance of `output-block` ready to write again, or
          # returns an error if provided access mode does not allow writing operations.
          [buffer] > write
            this. > @
              if.
                can-write.not
                [] >>
                  $ > this
                  error > @
                    sprintf
                      "Can't write to file with provided access mode '%s'"
                      * access
                seq *
                  written-bytes buffer
                  output-block

        # Writes given `buffer` of bytes to file output stream and returns `org.eolang.true`.
        #
        # Attention! The object is for internal usage only, please
        # don't use the object programmatically outside of `file` object.
        [buffer] > written-bytes ?
