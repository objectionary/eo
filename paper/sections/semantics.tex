In order to explain how declarative expressions of \phic{} can
be translated into imperative instructions of a target computing platform, we
\begin{inparaenum}[1)]
\item represent object model as \emph{object graph},
\item introduce a set of \emph{graph modifying instructions} (SODG),
\item define \emph{transformation rules} between \phic{} expressions and SODGs,
\item suggest \emph{dataization algorithm} turning object graph into function composition.
\end{inparaenum}

\subsection{Object Graph}\label{ssec:graph}

Consider the object from \lrefs{book2}{book2-end},
which is also represented by the expression in Eq.~\ref{eq:book}.
Fig.~\ref{fig:book2} represents it as a graph.

\begin{figure}[t!]
\begin{phigure}
  \node[object] (v0) {$\Phi$};
  \node[object] (v2) [below right=0.5cm and 1.8cm of v0] {$v_2$};
    \draw (v0) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v2) node [attr] {\ff{book2}};
  \node[atom] (v1) [below left of=v0] {$v_1$} node[lambda] at (v1.south east) {$M_1$};
    \draw (v0) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (v1) node [attr] {\ff{memory}};
  \draw[ref] (v2) -- (v1) node [attr] {\ff{price}} node [locator] {$\Phi.\ff{memory}$};
  \node[object] (v4) [below left=1.5cm and 0.5cm of v2] {$v_4$};
    \draw (v2) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}}  (v4) node [attr] {\ff{title}};
  \node[empty] (v3) [below right=1cm and 1cm of v2] {$v_3$};
    \draw (v2) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v3) node [attr] {\ff{isbn}};
  \node[data] (d4) [below left=0.5cm and 1.5cm of v4] {$d_4$};
    \draw (v4) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (d4) node [attr] {$\Delta$};
  \node [anchor=south east] at (current bounding box.south east) {
  \begin{minipage}{15em}\raggedleft
    $d_{4} \to \ff{"Object Thinking"}$
  \end{minipage}};
\end{phigure}
\figcap{The object graph with a few objects from Eq.~\ref{eq:book2}, where
$d_4$ is \ff{"Object Thinking"} data and $M_1$ is a lambda expression defined
in the runtime.}
\label{fig:book2}
\end{figure}

The vertice at the top of the graph is the ``root'' object (see Def.~\ref{def:locator}),
where all other objects that are not anonymous (see Def.~\ref{def:parent}) are bound to.
The vertice $v_2$ is the abstract object \ff{book2}. The name of the object within the
scope of $\Phi$ is the label on the edge from $\Phi$ to $v_2$. The labeled edge
between $v_2$ and $v_3$ makes the object $v_3$ an attribute of $v_2$ with the
identifier \ff{isbn}. Even though the object $v_3$ is $\varnothing$, the graph
depicts it as any other object.

The rectangle attached to the vertice $v_1$ makes it an atom (see Def.~\ref{def:atom})
and $M_1$, the content of the rectangle, is its $\lambda$-term. Atoms
are depicted with double-lined circles. The data $d_4$
attached to the vertice $v_4$ by the named edge $\Delta$
is the text \ff{"Object Thinking"}.

There are six graphical elements that may be present on an object graph:
A \emph{circle} with a name inside it is an object.
A \emph{named edge} from a circle to another circle is an attribute of the departing object.
A \emph{snake} edge is the $\rho$ attribute.
A \emph{dotted} edge connects a copy with the origin.
A \emph{double-bordered} circle is an atom.
A \emph{rectangle} attached to a circle contains the $\lambda$-term of the atom.

\subsection{SODG}

In order to formalize the process of drawing an object graph,
we introduced a few SODGs:

\makeatletter\newlength\tdima
\newcommand\tabfill[1]{%
      \setlength\tdima{\linewidth}%
      \addtolength\tdima{\@totalleftmargin}%
      \addtolength\tdima{-\dimen\@curtab}%
      \parbox[t]{\tdima}{\raggedright#1\ifhmode\strut\fi}}
\makeatother
\begin{tabbing}
\hspace*{2.6cm}\= \kill
$\ff{ADD}(v_1)$
  \>
  \tabfill{Adds a new vertice $v_1$ to the graph:}
  \\
  \>
  \begin{phigure}
    \node[object] (v1) {$v_1$};
  \end{phigure}
  \\
$\ff{BIND}(e_1, v_1, v_2, a)$
  \>
  \tabfill{Adds a solid uni-directed edge $e_1$ labeled as $a$ from an existing vertice $v_1$ to an existing vertice $v_2$,
  making a snake edge if $a$ equals to $\rho$ and adding a reverse snake edge otherwise:}
  \\
  \> \begin{phigure}
    \node[object] (v1) {$v_1$};
    \node[object, right of=v1] (v2) {$v_2$};
    \draw (v1) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v2) node [attr] {$a$} node [edge-name] {$e_1$};
  \end{phigure}
  \\
$\ff{DOT}(e_1, m, v_3, e_2)$
  \>
  \tabfill{Deletes the edge $e_1$ going from $v_1$ to $v_2$,
    adding a new atom vertice $v_3$,
    connecting $v_1$ to $v_3$ with an edge $e_2$ labeled the same way as $e_1$,
    connecting $v_3$ and $v_2$ with an edge labeled as \ff{t},
    and
    attaching a rectangle with a special lambda expression to $v_3$:}
  \\
  \> \begin{phigure}
    \node[object] (v1) {$v_1$};
    \node[object, right=0.8cm of v1] (v2) {$v_2$};
    \draw (v1) -- (v2) node [attr] {$a$} node [edge-name] {$e_1$};
    \node[object, right=1cm of v2] (v1d) {$v_1$};
    \node[transforms, right=0.3cm of v2] {};
    \node[object, right=0.5cm of v1d] (v2d) {$v_2$};
    \node[atom, below=0.8cm of v1d] (v3) {$v_3$}
       node[lambda] at (v3.south east) {$\mathbb{R}(\xi.\ff{t}, m, s)$};
    \draw (v1d) -- (v3) node [attr] {$a$} node [edge-name] {$e_2$};
    \draw (v3) -- (v2d) node [attr] {\ff{t}};
  \end{phigure}
  \\
$\ff{COPY}(e_1, v_3, e_2)$
  \>
  \tabfill{Reconnects the edge $e_1$ going from $v_1$ to $v_2$,
    adding a new vertice $v_3$,
    connecting $v_1$ and $v_3$ with edge $e_1$,
    and connecting $v_3$ and $v_2$ with a new dotted edge $e_2$:}
  \\
  \> \begin{phigure}
    \node[object] (v1) {$v_1$};
    \node[object, right=0.8cm of v1] (v2) {$v_2$};
    \draw (v1) -- (v2) node [attr] {$a$} node [edge-name] {$e_1$};
    \node[object, right=1cm of v2] (v1d) {$v_1$};
    \node[transforms, right=0.3cm of v2] {};
    \node[object, right=0.7cm of v1d] (v2d) {$v_2$};
    \node[object, below right=0.8cm and 0.2cm of v1d] (v3) {$v_3$};
    \draw (v1d) -- (v3) node [attr] {$a$} node [edge-name] {$e_1$};
    \draw[parent] (v3) -- (v2d) node [edge-name] {$e_2$};
  \end{phigure}
  \\
$\ff{ATOM}(v_1, M_1)$
  \>
  \tabfill{Attaches a rectangle to an existing vertice $v_1$ with a lambda expression $M_1$ inside
  and adds the second border to $v_1$:}
  \\
  \> \begin{phigure}
    \node[object] (v1) {$v_1$};
    \node[transforms, right=0.3cm of v1] {};
    \node[atom, right=1cm of v1] (v1d) {$v_1$};
    \node[lambda] at (v1d.south east) {$M_1$};
  \end{phigure}
\\
$\ff{DATA}(v_1, \Gamma)$
  \>
  \tabfill{Changes the shape of an existing vertice $v_1$ to a polygon and sets its data to $\Gamma$:}
  \\
  \> \begin{phigure}
    \node[object] (v1) {$v_1$};
    \node[transforms, right=0.3cm of v1] {};
    \node[data, right=1cm of v1] (v1d) {$\Gamma$};
  \end{phigure}
\\
$\ff{REF}(e_1, v_1, k, a)$
  \>
  \tabfill{Starting from the vertice $v_1$,
    finds a vertice $v_2$ by the locator $k$
    and links them with an edge $e_1$ named as $a$ with a supplementary label $k$
    (omitting the circle around the vertice $v_2$ is a visual
    trick that helps avoid a long arrow, which would need to be drawn from $v_1$ to the
    found $v_2$ otherwise):}
  \\
  \> \begin{phigure}
    \node[object] (v1) {$v_1$};
    \node[dup, right of=v1] (v2) {$v_2$};
    \draw[ref] (v1) -- (v2) node [attr] {$a$} node [locator] {$k$} node [edge-name] {$e_1$};
  \end{phigure}
  \\
\end{tabbing}

All SODGs are idempotent, meaning that they have no additional effect
if they are called more than once with the same input parameters.
The object graph at Fig.~\ref{fig:book2} may be generated with the
following ordered sequence of SODGs:

\begin{twocols}
\begin{ffcode}
ADD(|$\Phi$|)
ADD(|$v_1$|);
ATOM(|$v_1$|, |$M_1$|);
BIND(|$\Phi$|, |$v_1$|, memory);
ADD(|$v_2$|);
BIND(|$\Phi$|, |$v_2$|, book2);
ADD(|$v_3$|);
BIND(|$v_2$|, |$v_3$|, isbn);
ADD(|$v_4$|);
BIND(|$v_2$|, |$v_4$|, title);
REF(e, |$v_2$|, |$\Phi$|.memory, price);
ADD(|$d_4$|);
BIND(|$v_4$|, |$d_4$|, |$\Delta$|);
\end{ffcode}
\end{twocols}

\subsection{Transformation Rules}

In order to formalize the mechanism of turning \phic{} formulas into an object graph,
we introduced a number of transformation rules. \rrule{abstract} explains how
an abstract object gets transformed to a sequence of SODGs:
\begin{equation*}
\dfrac
  {v_i | x(a_1, a_2, \dots, a_n) \mapsto \llbracket E \rrbracket}
  {\begin{matrix}
    \ff{ADD}(v_{i\rr x}) \quad \ff{BIND}(v_i, v_{i\rr x}, x) \\
    \forall j \in [1; n] \left( \ff{ADD}(v_{i\rr x\rr j}) \quad \ff{BIND}(v_{i\rr x}, v_{i\rr x\rr j}, a_j) \right) \\
    v_{i\rr x}|E
  \end{matrix}}
  \jrule{abstract}
\end{equation*}

The $v|E$ notation at the premise part of the rule
means ``$E$ stands while the focus is at $v$,'' where
$E$ is an expression and $v$ is an element of the graph, for example a vertice or an edge.

The hierarchical vertice indexing notation is used in order to
avoid duplication of indexes. Thus, the index of the vertice
$v_{i\rr x\rr 1}$ is unique on the graph. The symbol ``$\rr$'' is used
as a delimiter between parts of the index. We decided to use this symbol
instead of a more traditional dot because the semantic of the dot
is already occupied by the dot notation in \phic{}.

For the sake of simplicity of the graphs, the hierarchical notation won't be
used in practical examples below. Instead, single integer indexes will
be used to denote vertices and edges, being incremented sequentially
in order to avoid duplication.

Consider for example the abstract object bound to the attribute \ff{is-inside} in Eq.~\ref{eq:c-empty}.
The premise $v_5|E$ will stand when the focus is at the vertice representing the object \ff{circle},
where $v_5$ would be the vertice of it (the numbers
$5$ and $12$ don't mean anything and are just placeholders):
\begin{equation*}
\dfrac
  {\quad v_5 | \ohat{x}{\ff{is-inside}}(\ohat{a_1}{\ff{p}}) \mapsto \llbracket \ohat{E}{\varphi \mapsto \dots} \rrbracket}
  {\begin{matrix}
    \ff{ADD}(v_{12}) \quad \ff{BIND}(v_5, v_{12}, \ff{is-inside}) \\
    \ff{ADD}(v_{13}) \quad \ff{BIND}(v_{12}, v_{13}, \ff{p}) \\
    v_{12}|\varphi \mapsto \dots
  \end{matrix}}
\end{equation*}
The effect of all SODGs generated by this rule would be the following
on an object graph:

\begin{center}\begin{phigure}
  \node[object] (v5) {$v_5$};
  \node[transforms, right=0.3cm of v5] {};
  \node[object, right=1cm of v5] (v5d) {$v_5$};
  \node[object, below right=0.6cm and 1.5cm of v5d] (v12) {$v_{12}$};
    \draw (v5d) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}}  (v12) node [attr] {\ff{is-inside}};
  \node[object, below left=1cm of v12] (v13) {$v_{13}$};
    \draw (v12) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}}  (v13) node [attr] {\ff{p}};
\end{phigure}\end{center}

The $E$ part of the premise is the internals of the abstract object \ff{is-inside}.
It will be processed by one of the rules, while looking at $v_{12}$.
\rrule{comma} explains how a comma-separated series of expressions break
into individual rules (since the expression inside \ff{is-inside} is the only
one, this rule is not applicable):
\begin{equation*}
\dfrac
  {v_i | E_1,E_2,\dots,E_n}
  {v_i | E_1 \quad v_i|E_2 \quad \dots \quad v_i|E_n}
  \jrule{comma}
\end{equation*}

\rrule{attribute} turns an attribute into an edge on the graph
and then continues processing the expression that goes after the
object being referred, by looking at the created edge:
\begin{equation*}
\dfrac
  {v_i | a \mapsto x \; E}
  {\ff{REF}(e_{i\rr a}, v_i,x,a) \quad v_i|x \quad e_{i\rr a}|E}
  \jrule{attribute}
\end{equation*}
The notation ``$x \; E$'' in the premise of \rrule{attribute} splits the expression
under consideration into two parts: the ``head'' of a single identifier
$x$ and the ``tail'' of the expression as $E$.
In the conclusion part of the rule a vertice is found using the locator $x$
and then a new edge is added, starting from the current vertice and arriving
to the vertice found. Strictly, $x$ must be a single identifier. However,
in a more relaxed mode it is possible to have a longer locator as the head
of the expression. For example, the expression $\rho.\rho.\ff{p}$ can be split
strictly on $\rho$ as the head and $\rho.\ff{p}$ as the tail; but it
also can be split on $\rho.\rho$ as the head and $\ff{p}$ as the tail. Longer
locators in the head part of the expression are only allowed if the vertice
they refer to already exists on the graph.
\rrule{attribute} also processes $x$ in the conclusion part,
providing other rules the opportunity to deal with it.
In particular, \rrule{data} may process $x$ if it is data.

The tranformation of the internals of \ff{is-inside} with \rrule{attribute}
would look like the following:
\begin{equation*}
\dfrac
  {v_{12} | \ohat{a}{\varphi} \mapsto \ohat{x}{\rho} \; \ohat{E}{.\ff{distance}(\ff{p}).\ff{lte}(\ff{radius})}}
  {\ff{REF}(e_{14}, v_{12},v_{5},\varphi) \quad e_{14}|.\ff{distance}(\ff{p}).\ff{lte}(\ff{radius})}
\end{equation*}
Here $\rho$ represents the $x$ part of the premise and the expression
that starts with a dot represents the $E$ part. At the conclusion,
$x$ is being replaced with $v_5$, because $\rho$ from the vertice $v_{12}$ points
to it: it is the parent object of $v_{12}$. The edge $e_{14}$ created by the \ff{REF}
is used in the expression that finishes the conclusion, triggering the processing
of the tail part of the formula: the head is the $\rho$, while the tail
is the dot and everything that goes after it.
Visually, the execution of \rrule{attribute} would produce the following
changes on the object graph (the vertice $v_{13}$ is not shown for the sake of brevity):

\begin{center}\begin{phigure}
  \node[object] (v5) {$v_5$};
  \node[object, below right=1cm and 1.1cm of v5] (v12) {$v_{12}$};
    \draw (v5) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v12) node [attr] {\ff{is-inside}};
  \node[transforms, right=1.4cm of v5] {};
  \node[object, right=2.4cm of v5] (v5d) {$v_5$};
  \node[object, below right=1cm and 1.1cm of v5d] (v12d) {$v_{12}$};
    \draw (v5d) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v12d) node [attr] {\ff{is-inside}};
  \draw (v12d) edge [bend right=50] node [attr] {$\varphi$} node [edge-name] {$e_{14}$} (v5d);
\end{phigure}\end{center}

The dot notation is resolved by \rrule{dot}, which unlike previously
seen rules, deals with an edge instead of a vertice:
\begin{equation*}
\dfrac
  {e_i | .x \; E}
  {\ff{DOT}(e_i, x, v_{i\rr x}, e_{i\rr x\rr 1}) \quad e_{i\rr x\rr 1}|E}
  \jrule{dot}
\end{equation*}
Here $x$ is the identifier that goes after the dot and $E$ is everything
else, the tail of the expression. In this example, the instance
of the rule would look like this:
\begin{equation*}
\dfrac
  {e_{14} | \ohat{.x}{.\ff{distance}} \; \ohat{E}{(\ff{p}).\ff{lte}(\ff{radius})}}
  {\ff{DOT}(e_{14}, \ff{distance}, v_{15}, e_{16}) \quad e_{16}|(\ff{p}).\ff{lte}(\ff{radius})}
\end{equation*}
Visually, the execution of this rule would lead to the following
modifications on the object graph:

\begin{center}\begin{phigure}
  \node[object] (v5) {$v_5$};
  \node[object, below right=1cm and 1.1cm of v5] (v12) {$v_{12}$};
    \draw (v5) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v12) node [attr] {\ff{is-inside}};
  \draw (v12) edge [bend right=50] node [attr] {$\varphi$} node [edge-name] {$e_{14}$} (v5);
  \node[transforms, right=1.3cm of v5] {};
  \node[object,right=2cm of v5] (v5d) {$v_5$};
  \node[object, below right=1cm and 1.1cm of v5d] (v12d) {$v_{12}$};
    \draw (v5d) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v12d) node [attr] {\ff{is-inside}};
  \node[atom, above right=1cm and 0cm of v12d] (v15) {$v_{15}$}
    node[lambda] at (v15.south east) {$\mathbb{R}(\xi.\ff{t}, \ff{distance}, s)$};
    \draw (v12d) -- (v15) node [attr] {$\varphi$} node [edge-name] {$e_{16}$};
    \draw (v15) -- (v5d) node [attr] {\ff{t}};
\end{phigure}\end{center}

The application of arguments to abstract objects is transformed
to the object graph by \rrule{copy}, which also deals
with an edge instead of a vertice:
\begin{equation*}
\dfrac
  {e_i | (E_1) \; E_2}
  {\ff{COPY}(e_i, v_{i\rr 1}, e_{i\rr 2}) \quad v_{i\rr 1}|E_1 \quad e_{i}|E_2}
  \jrule{copy}
\end{equation*}
To continue the processing of the expression inside the abstract object
\ff{is-inside} the rule may be applied as the following:
\begin{equation*}
\dfrac
  {e_{16} | \ohat{E_1}{(\ff{to} \mapsto \xi.\ff{p})} \; \ohat{E_2}{.\ff{lte}(\ff{radius})}}
  {\ff{COPY}(e_{16}, v_{17}, e_{18}) \quad v_{17}|\ff{to} \mapsto \xi.\ff{p} \quad e_{16}|.\ff{lte}(\ff{radius})}
\end{equation*}
Visually, this rule would produce the following modifications on the graph:

\begin{center}\begin{phigure}
  \node[object] (v12) {$v_{12}$};
  \node[atom, above right=1cm and 0cm of v12] (v15) {$v_{15}$}
    node[lambda] at (v15.south east) {$M_{15}$};
    \draw (v12) -- (v15) node [attr] {$\varphi$} node [edge-name] {$e_{16}$};
  \node[transforms, right=1cm of v15] {};
  \node[object, right=2cm of v12] (v12d) {$v_{12}$};
  \node[atom, above right=1cm and 0cm of v12d] (v15d) {$v_{15}$}
    node[lambda] at (v15d.south east) {$M_{15}$};
    \draw (v12) -- (v15) node [attr] {$\varphi$} node [edge-name] {$e_{16}$};
  \node[object, above right=0cm and 1.5cm of v12d] (v17) {$v_{17}$};
    \draw (v12d) -- (v17) node [attr] {$\varphi$} node [edge-name] {$e_{16}$};
    \draw[parent] (v17) edge [bend right=30] node [edge-name] {$e_{18}$} (v15d);
\end{phigure}\end{center}

The last rule deals with data, such as integers, string literals, and so on
(together referred to as $\Gamma$):
\begin{equation*}
\dfrac
  {v_i | \Gamma}
  {\ff{ADD}(d_i) \quad \ff{BIND}(v_i,d_i,\Delta) \quad \ff{DATA}(d_i, \Gamma)}
  \jrule{data}
\end{equation*}

There is also one rule, which transforms atoms to the object graph by \rrule{lambda}
attaching lambda expressions to vertices:
\begin{equation*}
\dfrac
  {v | \lambda s . M}
  {\ff{ATOM}(v, M)}
  \jrule{lambda}
\end{equation*}
Visually, the rule would produce the following modifications on the graph
for Eq.~\ref{def:stdout}:

\begin{center}\begin{phigure}
  \node[object] (phi) {$\Phi$};
  \node[object, below right=1cm of phi] (v1) {$v_{1}$};
    \draw (phi) -- (v1) node [attr] {\ff{stdout}};
  \node[transforms, right=1cm of phi] {};
  \node[object, right=2cm of phi] (phi-d) {$\Phi$};
  \node[atom, below right=1cm of phi-d] (v1d) {$v_{1}$}
    node[lambda] at (v1d.south east) {$M_\text{stdout}$};
    \draw (phi-d) -- (v1d) node [attr] {\ff{stdout}};
\end{phigure}\end{center}

In order to demonstrate a larger example, Fig.~\ref{fig:is} shows
an object graph, which the described rules
would generate by transforming the object \ff{is} from Eq.~\ref{eq:is}.

\subsection{Dataization}

We define ``dataization'' as a process of turning an object into data,
which said object \emph{represents}. For example, the object at
\lref{sum-instance} represents an algebraic sum of three integers.
The process of dataization expects each object to know what data
it represents and if it doesn't know it, the object must know
where to get the data. The object \ff{sum} is not data, but
it knows how to calculate it. Once being asked to turn itself into
data it will ask all its three inner object the same question:
``What data you represent?'' They are integers and will return the
data they have attached to their attributes $\Delta$. Then, the object
\ff{sum}, using its $\lambda$-term, will calculate the arithmetic
sum of the numbers returned by its inner objects.

Visually, the object \ff{sum} from \lref{sum-instance} may be represented
by the following object graph:

\begin{center}\begin{phigure}
  \node[object] (v0) {$\Phi$};
  \node[atom, below right=1cm of v0] (v1) {$v_{1}$}
    node[lambda] at (v1.south east) {$\sum a_i$};
    \draw (v0) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v1) node [attr] {\ff{sum}};
  \node[object, above right=1.2cm and 2.8cm of v1] (v2) {$v_{2}$};
    \draw[parent] (v2) edge [bend right=30] (v1);
  \node[object, below left=1cm of v2] (v3) {$v_{3}$};
    \draw (v2) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (v3) node [attr] {$a_1$};
  \node[data, below=0.7cm of v3] (d3) {\ff{8}};
    \draw (v3) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (d3) node [attr] {$\Delta$};
  \node[object, below=1cm of v2] (v4) {$v_{4}$};
    \draw (v2) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v4) node [attr] {$a_2$};
  \node[data, below=0.7cm of v4] (d4) {\ff{13}};
    \draw (v4) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (d4) node [attr] {$\Delta$};
  \node[object, below right=1cm of v2] (v5) {$v_{5}$};
    \draw (v2) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v5) node [attr] {$a_3$};
  \node[data, below=0.7cm of v5] (d5) {\ff{-9}};
    \draw (v5) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (d5) node [attr] {$\Delta$};
\end{phigure}\end{center}

The dataization of $v_2$, which is an anonymous copy of \ff{sum} with
three arguments $v_3$, $v_4$, and $v_5$, would produce an arithmetic
sum of three integers calculated by the $\lambda$-term of $v_1$.

We suggest the following recursive object discovery
algorithm, which finds a vertice in a graph by its locator $k$ and
returns a vertice connected to it as an attribute $a$:

\begin{twocols}
\begin{algo}
\kw{function} $\mathbb{R}(k,a,S)$ \\
  \tab $v \gets k$ \\
  \tab \kw{if} $k$ is a locator with a dot inside \\
  \tab\tab $a' \gets$ after the last dot in $k$ \\
  \tab\tab $k' \gets$ before $a'$ in $k$ \\
  \tab\tab $v \gets$ $\mathbb{R}(k', a', S)$ \\
  \tab \kw{end if} \\
  \tab \kw{if} $v = \xi$ \kw{then} $v \gets S[0]$ \\
  \tab \kw{if} $v = \rho$ \kw{then} $v \gets S[1]$ \\
  \tab \kw{if} $v$ has $a$-edge to $\tau$ \kw{then} \kw{return} $\tau$ \\
  \tab \kw{if} $v$ has $\varphi$-edge to $\tau$ \kw{then} \kw{return} $\mathbb{R}(\tau, a, \tau + S)$ \\
  \tab \kw{if} $v$ has a dotted edge to $\tau$ \kw{then} \kw{return} $\mathbb{R}(\tau, \xi.a, \tau + S)$ \\
  \tab \kw{if} $v$ has $M$ \kw{then} \kw{return} $\mathbb{R}((\lambda s.M \; v + S), a, S)$ \\
  \tab \kw{return} $\perp$ \\
\kw{end}
\end{algo}
\end{twocols}

Here, $S$ is a vector of vertices, while $v+S$ produces a new vector
where $v$ stays at the first position and all other elements of $S$ follow.
The notation $S[i]$ denotes the $i$-th element of the vector, while
counting starts with zero.

The notation $(\lambda s.M \; v + S)$ means creating a function from
the $\lambda$-term $M$ with one parameter $s$ and then calculating
it with the argument $v + S$.
It is expected that the function returns a locator of a vertice or
the vertice itself, where the locator can be derived as
the shortest path from $\Phi$ to the given vertice.
The vector $s$, provided to the
function as its parameter, is used in $M$ when it is necessary
to use $\mathbb{R}$ in order to find some object.

If a function returns data, which doesn't have a locator, a new vertice
$v_i$ is created implicitly with the locator $\Phi.v_i$, and
a single attribute $\Delta$ connected to the data returned, where
$i$ is the next available index in the graph.

For example, $\mathbb{R}(\Phi.\ff{c}.\ff{center}.\ff{y},
\Delta, \varnothing)$ being executed on the graph presented at the
Fig.~\ref{fig:is} would return the vertice $d_{21}$, which is $+9$.

We also define a dataization function, which turns an object into data:

\begin{algo}
\kw{function} $\mathbb{D}(k)$ \\
  \tab \kw{return} $\mathbb{R}(k, \Delta, \varnothing)$ \\
\kw{end}
\end{algo}

The execution of the function $\mathbb{D}(x)$, where $x$ is the
``program'' object, leads to the execution of the entire program.
Program terminates with an error message when $\mathbb{D}(x)$ is $\perp$.

\begin{figure*}
\resizebox{.75\textwidth}{!}{
\begin{phigure}
  \node[object] (v0) {$\Phi$};
  \node[object] (v1) [right of=v0] {$v_1$};
    \draw (v0) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v1) node [attr] {\ff{circle}};
  \node[object] (v2) [below of=v1] {$v_2$};
    \draw (v1) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v2) node [attr] {\ff{center}};
  \node[object] (v3) [below left of=v1] {$v_3$};
    \draw (v1) -- pic[sloped,rho,auto,swap]{parallel arrow={-0.3,-0.15}} (v3) node [attr] {\ff{radius}};
  \node[object] (v4) [below right of=v1] {$v_4$};
    \draw (v1) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v4) node [attr] {\ff{is-inside}};
  \node[object] (v6) [below right=1cm of v4] {$v_6$};
    \draw (v4) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v6) node [attr] {\ff{p}};
  \node[dup] (v2d1) [right=2.1cm of v1] {$v_2$};
    \draw[ref] (v1) -- (v2d1) node [attr] {$\varphi$}  node [locator] {$\xi.\ff{center}$};
  \node[atom] (v5) [above right=0.5cm and 3cm of v4] {$v_5$}
    node[lambda] at (v5.south east) {$M_5$};
  \node[dup] (v4d1) [above left=0.5cm of v5] {$v_4$};
    \draw[rho] (v5) -- (v4d1);
  \node[object] (v25) [below=0.6cm of v5] {$v_{25}$};
    \draw[parent] (v25) -- (v5);
  \draw (v4) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v25) node [attr] {$\varphi$};
  \node[dup] (v3d1) [below=1.5cm of v25] {$v_3$};
    \draw[ref] (v25) -- (v3d1) node [attr] {\ff{other}}  node [locator] {$\rho.\rho.\ff{radius}$};
  \node[atom] (v7) [right=2cm of v5] {$v_7$}
    node[lambda] at (v7.south east) {$M_7$};
  \node[dup] (v5d1) [above left=0.5cm of v7] {$v_5$};
    \draw[rho] (v7) -- (v5d1);
  \node[object] (v24) [below=0.6cm of v7] {$v_{24}$};
    \draw[parent] (v24) -- (v7);
    \draw (v5) edge[bend left=30] node [attr] {\ff{t}} pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v24);
  \node[dup] (v6d1) [below=1cm of v24] {$v_6$};
    \draw[ref] (v24) -- (v6d1) node [attr] {\ff{to}}  node [locator] {$\rho.\rho.\ff{p}$};
  \node[dup] (v2d1) [right=1.8cm of v7] {$v_2$};
    \draw[ref] (v7) -- (v2d1) node [attr] {\ff{t}}  node [locator] {$\rho.\rho.\rho.\varphi$};

  \node[object] (v15) [below=0.6cm of v2] {$v_{15}$};
    \node[dup] (v0d1) [left=1cm of v15] {$\Phi$};
    \draw (v0d1) -- (v15) node [attr] {\ff{point}};
  \node[object] (v16) [below left=1cm of v15] {$v_{16}$};
    \draw (v15) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (v16) node [attr] {\ff{x}};
  \node[object] (v17) [below right=1cm of v15] {$v_{17}$};
    \draw (v15) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v17) node [attr] {\ff{y}};
  \node[atom] (v14) [below=2cm of v15] {$v_{14}$} node[lambda] at (v14.south east) {$M_{14}$};
    \draw (v15) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v14) node [attr] {\ff{distance}};
  \node[object] (v18) [left=1cm of v14] {$v_{18}$};
    \draw (v14) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (v18) node [attr] {\ff{to}};

  \node[object] (v10) [below right=1cm and 5cm of v15] {$v_{10}$};
    \node[dup] (v0d2) [left=1cm of v10] {$\Phi$};
    \draw (v0d2) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v10) node [attr] {\ff{c}};
  \node[dup] (v1d1) [above right=0.8cm of v10] {$v_{1}$};
    \draw[parent] (v10) -- (v1d1);
  \node[object] (v19) [below left=1.5cm of v10] {$v_{19}$};
    \draw (v10) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (v19) node [attr] {\ff{radius}};
  \node[data] (d19) [below left=1cm of v19] {\texttt{+40}};
    \draw (v19) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (d19) node [attr] {$\Delta$};
  \node[object] (v11) [below right=2cm and 0.5cm of v10] {$v_{11}$};
    \draw (v10) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v11) node [attr] {\ff{center}};
  \node[dup] (v15d1) [left=1cm of v11] {$v_{15}$};
    \draw[parent] (v11) -- (v15d1);
  \node[object] (v20) [below left=1cm of v11] {$v_{20}$};
    \draw (v11) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (v20) node [attr] {\ff{x}};
  \node[data] (d20) [below=1cm of v20] {\texttt{-3}};
    \draw (v20) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (d20) node [attr] {$\Delta$};
  \node[object] (v21) [below right=1cm of v11] {$v_{21}$};
    \draw (v11) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v21) node [attr] {\ff{y}};
  \node[data] (d21) [below=1cm of v21] {\texttt{+9}};
    \draw (v21) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (d21) node [attr] {$\Delta$};

  \node[object] (v12) [above right=0.2cm and 4cm of v10] {$v_{12}$};
    \node[dup] (v0d3) [left=1cm of v12] {$\Phi$};
    \draw (v0d3) -- (v12) node [attr] {\ff{is}};
  \node[dup] (v1d2) [above left=0.8cm of v12] {$v_{1}$};
    \draw[parent] (v12) -- (v1d2);
  \node[dup] (v10d2) [right=1cm of v12] {$v_{10}$};
    \draw[rho] (v12) -- (v10d2);
  \node[object] (v13) [below right=1cm and 0.5cm of v12] {$v_{13}$};
    \draw (v12) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v13) node [attr] {\ff{p}};
  \node[dup] (v15d2) [left=1cm of v13] {$v_{15}$};
    \draw[parent] (v13) -- (v15d2);
  \node[object] (v22) [below left=1cm of v13] {$v_{22}$};
    \draw (v13) -- pic[sloped,rho]{parallel arrow={-0.3,-0.15}} (v22) node [attr] {\ff{x}};
  \node[data] (d22) [below=1cm of v22] {\texttt{+1}};
    \draw (v22) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (d22) node [attr] {$\Delta$};
  \node[object] (v23) [below right=1cm of v13] {$v_{23}$};
    \draw (v13) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (v23) node [attr] {\ff{y}};
  \node[data] (d23) [below=1cm of v23] {\texttt{+7}};
    \draw (v23) -- pic[sloped,rho]{parallel arrow={0.3,-0.15}} (d23) node [attr] {$\Delta$};

  \node [anchor=south west] at (current bounding box.south west) {
  \begin{minipage}{25em}\raggedright
    $M_{14} \to \sqrt{\begin{matrix*}[l](\mathbb{R}(\xi.\ff{to}.\ff{x}, \Delta, s)-\mathbb{R}(\rho.\ff{x}, \Delta, s))^2 + \\ + (\mathbb{R}(\xi.\ff{to}.\ff{y}, \Delta, s)-\mathbb{R}(\rho.\ff{y}, \Delta, s))^2\end{matrix*}}$ \\
    $M_5 \to \mathbb{R}(\xi.\ff{t}, \ff{lte}, s)$ \\
    $M_7 \to \mathbb{R}(\xi.\ff{t}, \ff{distance}, s)$ \\
  \end{minipage}};
\end{phigure}}
\figcap{The graph of the object \ff{is} from Eq.~\ref{eq:is}.}
\label{fig:is}
\end{figure*}

