The proposed \phic{} is based on set theory~\citep{jech2013set} and lambda calculus,
representing objects as sets of pairs and their internals as $\lambda$-terms.
The rest of the section contains formal definitions of
data, objects, attributes, abstraction, application, decoration, and dataization.

\subsection{Objects and Data}

\begin{definition}\label{def:object}
An \textbf{object} is a set of ordered pairs $(a_i, v_i)$ such that
$a_i$ is an identifier, all $a_i$ are different, and $v_i$ is an object.
\end{definition}

An identifier is either $\varphi$, $\rho$, $\nu$, or, by convention, a text without
spaces starting with a small-case English letter in typewriter font.

The object at \lref{book} may be represented as
\begin{equation}\label{eq:book}
\begin{split}
\ff{book} & = \left\{\begin{matrix*}[l]
  (\ff{isbn}, \varnothing) \\
\end{matrix*}\right\},
\end{split}
\end{equation}
where \ff{isbn} is an identifier and $\varnothing$ is an empty
set, which is a proper object, according to the Def.~\ref{def:object}.

\begin{definition}\label{def:data}
An object may have properties of \textbf{data},
which is a computation platform dependable entity and is not
decomposable any further within the scope of \phic{}.
\end{definition}

What exactly is data may depend on the
implementation platform, but most certainly would include
byte arrays, integers, floating-point numbers,
string literals, and boolean values.

The object at \lrefs{book2}{book2-end} may be represented as
\begin{equation}\label{eq:book2}
\begin{split}
\ff{book2} & = \left\{\begin{matrix*}[l]
  (\ff{isbn}, \varnothing) \\
  (\ff{title}, \ff{"Object Thinking"}) \\
  (\ff{price}, \ff{memory}) \\
\end{matrix*}\right\}, \\
\end{split}
\end{equation}
where \ff{isbn}, \ff{title}, and \ff{price} are identifiers,
\ff{memory} is an object defined somewhere else,
and the text in double quotes is data.

\subsection{Attributes}

\begin{definition}\label{def:attribute}
In an object $x$, $a$ is a free \textbf{attribute}
with the \textbf{name} $a$
iff $(a, \varnothing) \in x$; it is a bound attribute
with the \textbf{value} $v$
iff $\exists (a, v)\in x$ and $v\not=\varnothing$;
\end{definition}

In Eq.~\ref{eq:book2}, identifiers \ff{isbn}, \ff{title}, and \ff{price}
are the attributes of the object \ff{book2}.
The attribute \ff{isbn} is free, while the other two are bound.

\begin{definition}\label{def:dot}
If $x$ is an object and $\exists (a, v) \in x$, then $v$ may be referenced as $x.a$;
this referencing mechanism is called \textbf{dot notation}.
\end{definition}

Both free and bound attributes of an object are accessible using
the dot notation. There is no such thing as
visibility restriction in \phic{}:
all attributes are visible to all objects outside of the one they belong to.

It is possible to chain attribute references using dot notation, for example
$\ff{book2}.\ff{price}.\ff{neg}$ is a valid expression, which means
``taking the attribute \ff{price} from the object \ff{book2} and then
taking the attribute \ff{neg} from it.''

\begin{definition}\label{def:scope}
If $x(a_i, v_i)$ is an object, then $\hat{x}$, a set consisting of all $a_i$,
is its \textbf{scope} and the cardinality of $|\hat{x}|$ is
the \textbf{arity} of $x$.
\end{definition}

For example, the scope of the object at Eq.~\ref{eq:book2} consists of three identifiers:
\ff{isbn}, \ff{title}, and \ff{price}.

\subsection{Abstraction}

\begin{definition}\label{def:abstraction}
An object $x$ is \textbf{abstract} iff at least one of its attributes is free,
i.e. $\exists (a, \varnothing)\in x$;
the process of creating such an object is called \textbf{abstraction}.
\end{definition}

An alternative ``arrow notation'' may be used to denote an object $x$ in a more
compact way, where free attributes stay in the parentheses on the left side of the
mapping symbol $\mapsto$ and pairs,
which represent bound attributes, stay on the right side, in double-square brackets.
Eq.~\ref{eq:book2} may be written as
\begin{equation}\label{eq:book2-compact}
\begin{split}
& \ff{book2}(\ff{isbn}) \mapsto \llbracket \br
& \quad \ff{title} \mapsto \ff{"Object Thinking"}, \br
& \quad \ff{price} \mapsto \ff{memory} \br
& \rrbracket. \\
\end{split}
\end{equation}

\subsection{Application}

\begin{definition}\label{def:application}
If $x$ is an abstract object and $y$ is an object
  where $\hat{y}\subseteq\hat{x}$,
  then an \textbf{application} of $y$ to $x$ is
  a \textbf{copy} of $x$, a new object that consists of pairs $(a\in\hat{x},v)$ such that
  $v=y.a$ if $x.a=\varnothing$ and $v=x.a$ otherwise.
\end{definition}

Application makes some free attributes of $x$ bound---by binding objects to them.
The produced object has exactly the same set of attributes, but some of them,
which were free before, become bound.

It is not expected that all free attributes turn into bound ones during application.
Some of them may remain free, which will lead
to creating a new abstract object. To the contrary,
if all free attributes are substituted with \emph{arguments} during copying,
a newly created object will be \emph{closed}.

Once set, bound attributes may not be reset.
This may be interpreted as \emph{immutability} property of objects.

Arrow notation may also be used to denote object copying,
where the names of the attributes, which remain free, stay in the brackets
on the left side of the mapping symbol $\mapsto$,
while objects $P$ provided as arguments stay on the right side,
in the brackets. For example, the object at \lref{point-copy} may be written as
\begin{equation}\label{eq:point}
\begin{split}
& \ff{point}(\ff{x} \mapsto \ff{5}, \ff{y} \mapsto \ff{-3}).\ff{distance}(\br
& \quad \ff{to} \mapsto \ff{point}(\ff{x} \mapsto \ff{13}, \ff{y} \mapsto \ff{3.9}) \br
& ),
\end{split}
\end{equation}
and may further be simplified since the order of parameters is obvious:
\begin{equation}
\begin{split}
\ff{point}(\ff{5}, \ff{-3}).\ff{distance}(\ff{point}(\ff{13}, \ff{3.9})).
\end{split}
\end{equation}

An application without arguments is a copy of an object. For example,
in these expressions the attribute \ff{p1} is bound to the same object
as the attribute \ff{p}, while the attribute \ff{p2} is bound to a new
object, a copy of \ff{p}:
\begin{equation*}
\begin{split}
& \ff{p} \mapsto \ff{point}(\ff{5}, \ff{-3}),\\
& \ff{p1} \mapsto \ff{p},\\
& \ff{p2} \mapsto \ff{p}().\\
\end{split}
\end{equation*}

\begin{definition}\label{def:formation}
The process of creating an object that is not a copy of another object
is called \textbf{formation}.
\end{definition}

Syntactically, object formation is denoted by double square brackets,
as in Eq.~\ref{eq:book2-compact}, to the contrary of object application,
which is denoted by round brackets, as in Eq.~\ref{eq:point}.
Object abstraction is a special case of object formation.
The following expression is a formation of the object $x$:
\begin{equation*}
x \mapsto [[ y -> t ]].
\end{equation*}

\subsection{Parent and Home}

\begin{definition}\label{def:parent}
If $x$ is an object, then $x.\rho$ is its \textbf{parent},
which is the object that created $x$.
\end{definition}

An object may be created either by
abstraction or application. In case of abstraction, an object
is created by another abstract object, for example:
  \begin{equation}
  \begin{split}
  & x \mapsto \llbracket y \mapsto \llbracket z \mapsto t \rrbracket \rrbracket \br
  & x.y.\rho = x \br
  & x.y.z.\rho = y.
  \end{split}
  \end{equation}
In case of application, an object is created by the prepending object:
  \begin{equation}
  \begin{split}
  & a \mapsto \llbracket b \mapsto c, d \mapsto e.f, g \mapsto h.i(j) \rrbracket \br
  & a.b.\rho = a \br
  & a.d.\rho = e \br
  & a.g.\rho = h.
  \end{split}
  \end{equation}

\begin{definition}\label{def:home}
If $x$ is an object, then $x.\sigma$ is its \textbf{home} object, which
is the $\rho$ of the abstract object $x$ is a copy of.
\end{definition}

For example:
\begin{equation}
\begin{split}
& x \mapsto \llbracket y(f) \mapsto \llbracket \rrbracket \rrbracket \br
& x.y.\rho = x \br
& z \mapsto \llbracket t \mapsto x.y(42) \rrbracket \br
& z.t.\rho = z \br
& z.t.\sigma = x.
\end{split}
\end{equation}

\subsection{Decoration}\label{sec:decoration}

\begin{definition}\label{def:decorator}
If $x$ and $y$ are objects and $x.\varphi = y$, then
  $\forall a (x.a = y.a)$ if $a \not\in \hat{x}$;
  this means that $x$ is \textbf{decorating} $y$.
\end{definition}

Here, $\varphi$ is a special identifier denoting the object,
known as a \emph{decoratee}, being decorated
within the scope of the decorator.

For example, the object at \lrefs{circle}{circle-end} would
be denoted by this formula:
\begin{equation}\label{eq:c-empty}
\begin{split}
& \ff{circle}(\ff{center}, \ff{radius}) \mapsto \llbracket \br
& \quad \varphi \mapsto \ff{center}, \br
& \quad \ff{is-inside}(\ff{p}) \mapsto \llbracket \br
& \quad \quad \varphi \mapsto \rho.\varphi.\ff{distance}(\ff{p}).\ff{lte}(\ff{radius}) \br
& \quad \rrbracket \br
& \rrbracket,
\end{split}
\end{equation}
while the application of it would look like:
\begin{equation}
\begin{split}
\ff{c} & \mapsto \ff{circle}(\ff{point}(\ff{-3}, \ff{9}), \ff{40}),
\end{split}
\end{equation}
producing:
\begin{equation}\label{eq:c-fin}
\begin{split}
& \ff{c} \mapsto \llbracket \br
& \quad \ff{center} \mapsto \ff{point}(\ff{-3}, \ff{9}), \br
& \quad \ff{radius} \mapsto \ff{40}, \br
& \quad \varphi \mapsto \ff{center}, \br
& \quad \ff{is-inside}(\ff{p}) \mapsto \llbracket \br
& \quad \quad \varphi \mapsto \rho.\ff{distance}(\ff{p}).\ff{lte}(\ff{radius}) \br
& \quad \rrbracket \br
& \rrbracket.
\end{split}
\end{equation}

Because of decoration, the expression
$\rho.\varphi.\ff{distance}$ in Eq.~\ref{eq:c-empty} is semantically equivalent to a shorter expression
$\rho.\ff{distance}$ in Eq.~\ref{eq:c-fin}.

The following expression makes a new object \ff{is}, which represents
a sequence of object applications ending with a copy of \ff{lte}:
\begin{equation}\label{eq:is}
\begin{split}
& \ff{is} \mapsto \ff{c}.\ff{is-inside}(\ff{point}(\ff{1}, \ff{7})),
\end{split}
\end{equation}
producing:
\begin{equation}\label{eq:c-fin2}
\begin{split}
& \ff{c} \mapsto \llbracket \br
& \quad \ff{center} \mapsto \ff{point}(\ff{-3}, \ff{9}), \br
& \quad \ff{radius} \mapsto \ff{40}, \br
& \quad \varphi \mapsto \ff{center}, \br
& \quad \ff{is-inside} \mapsto \llbracket \br
& \quad \quad \ff{p} \mapsto \ff{point}(\ff{1}, \ff{7}), \br
& \quad \quad \varphi \mapsto \rho.\ff{distance}(\ff{p}).\ff{lte}(\ff{radius}) \br
& \quad \rrbracket \br
& \rrbracket.
\end{split}
\end{equation}

It is important to notice that attributes of a decoratee
don't belong to the scope of its decorator.

\subsection{Atoms}

\begin{definition}\label{def:atom}
If $\lambda s.M$ is a function of one argument $s$ returning an object,
then it is an abstract object called an \textbf{atom}, $M$ is its $\lambda$-term,
and $s$ is its free attribute.
\end{definition}

For example, the atom at \lref{sum-def} would be represented as
\begin{equation}
\begin{split}
& \ff{sum}(\ff{x}) \mapsto \lambda s . \sum\limits_{i=0}^{s[0].\ff{x}.\ff{size} - 1} s[0].\ff{x}.\ff{get}(i),
\end{split}
\end{equation}
where the function calculates an arithmetic sum of all items
in the tuple \ff{x} and returns the result as a data. The argument of
the function is a vector $s$ where the first element is the object under
consideration, the second element is its parent object, the third element
is the parent of the parent, and so on. Thus, $s[0]$ is the object
\ff{sum} itself, while $s[0].\ff{x}$ is its inner object \ff{x},
and $s[0].\ff{x}.\ff{get}(0)$ is the first element of it, if it is a tuple.
It is expected that the tuple has an attribute \ff{size} representing
the total number of elements in the tuple.

Atoms may have their $\lambda$-terms defined outside of \phic{} formal scope.
For example, the object at \lref{stdout} would be denoted as
\begin{equation}\label{def:stdout}
\ff{stdout}(\ff{text}) \mapsto \lambda s.M_\texttt{stdout},
\end{equation}
where $M_\texttt{stdout}$ is a $\lambda$-term defined externally.

In atoms, $\lambda$-terms are bound to $\lambda$ attribute.
Thus, a more formal form of the Eq.~\ref{def:stdout} is:
\begin{equation*}
\ff{stdout} \mapsto \llbracket \ff{text} \mapsto \varnothing, \lambda \mapsto M_\text{stdout} \rrbracket.
\end{equation*}

\subsection{Locators}

\begin{definition}\label{def:locator}
Object \textbf{locator} is a unique dot-separated not-empty
collection of identifiers prepended by either $\xi$, $\rho$, $\sigma$, or $\Phi$.
\end{definition}

Locators are used to avoid ambiguity when referencing objects.
For example, Eq.~\ref{eq:c-fin} may be refined as
\begin{equation}
\begin{split}
& \ff{c} \mapsto \llbracket \br
& \quad \ff{center} \mapsto \Phi.\ff{point}(\Phi.\ff{-3}, \Phi.\ff{9}), \br
& \quad \ff{radius} \mapsto \Phi.\ff{40}, \br
& \quad \varphi \mapsto \xi.\ff{center}, \br
& \quad \ff{is-inside}(\ff{p}) \mapsto \llbracket \br
& \quad \quad \varphi \mapsto \rho.\ff{distance}(\xi.\ff{p}).\ff{lte}( \br
& \quad \quad \quad \rho.\ff{radius} \br
& \quad \quad ) \br
& \quad \rrbracket \br
& \rrbracket,
\end{split}
\end{equation}
where $\xi$ denotes the current abstract object
and $\Phi$ refers to the anonymous closed ``root'' object.
Defining an object in a global scope
means binding it to the object $\Phi$, unless it is an anonymous
object, as the one at \lrefs{succ}{succ-end}.

The most precise and complete formula for the object in the
Eq.~\ref{eq:c-fin2} would also include attribute names for
the object application:
\begin{equation}
\begin{split}
& \ff{c} \mapsto \llbracket \br
& \quad \ff{center} \mapsto \Phi.\ff{point}( \br
& \quad \quad \ff{x} \mapsto \Phi.\ff{-3}, \br
& \quad \quad \ff{y} \mapsto \Phi.\ff{9} \br
& \quad ), \br
& \quad \ff{radius} \mapsto \Phi.\ff{40}, \br
& \quad \varphi \mapsto \xi.\ff{center}, \br
& \quad \ff{is-inside}(\ff{p}) \mapsto \llbracket \br
& \quad \quad \varphi \mapsto \xi.\rho.\ff{distance}(\ff{to} \mapsto \xi.\ff{p}).\ff{lte}( \br
& \quad \quad \quad \ff{other} \mapsto \xi.\rho.\ff{radius} \br
& \quad \quad ) \br
& \quad \rrbracket \br
& \rrbracket.
\end{split}
\end{equation}

\subsection{Constant}

\newcommand\cmapsto{\mapstochar\relbar\mathrel{\mkern-8mu}\mapsto}
\begin{definition}\label{def:identity}
If $x \mapsto \llbracket y \cmapsto z \rrbracket$ is an object
then $y$ is a \emph{constant} attribute, meaning that
the result of dataization of $x.y$ always equals to itself.
\end{definition}

\subsection{Identity}

\begin{definition}\label{def:constant}
If $x$ is an object then $x.\nu$ is a positive integer data object
with a unique identity of $x$ in the entire runtime scope.
\end{definition}

For example, without any other objects in scope it is safe
to assume the following, however there is no guarantee that
the actual numbers will be the same in all implementations:
\begin{equation}
\begin{split}
& \ff{x}(\ff{y}) \mapsto \llbracket \rrbracket \br
& \ff{z} \mapsto \ff{x} ( \ff{y} \mapsto \ff{42} ) \br
& \Phi.\nu = 0, \ff{x}.\nu = 1, \ff{42}.\nu = 2, \ff{z}.\nu = 3.
\end{split}
\end{equation}

