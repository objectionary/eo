%%
%% This is file `eolang.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% eolang.dtx  (with options: `package')
%% (The MIT License)
%% 
%% Copyright (c) 2021-2024 Yegor Bugayenko
%% 
%% Permission is hereby granted, free of charge, to any person obtaining a copy
%% of this software and associated documentation files (the 'Software'), to deal
%% in the Software without restriction, including without limitation the rights
%% to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
%% copies of the Software, and to permit persons to whom the Software is
%% furnished to do so, subject to the following conditions:
%% 
%% The above copyright notice and this permission notice shall be included in all
%% copies or substantial portions of the Software.
%% 
%% THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
%% IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
%% FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
%% AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
%% LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
%% OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
%% SOFTWARE.



\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{eolang}
[0000-00-00 0.0.0 Formulas and Graphs for EO Programming Language]

















































\RequirePackage{stmaryrd}
\RequirePackage{amsmath}
\let\Bbbk\relax\RequirePackage{amssymb}
\RequirePackage{fancyvrb}
\ifdefined\eolang@noshell\else\RequirePackage{iexec}\fi

\RequirePackage{pgfopts}
\RequirePackage{ifluatex}
\RequirePackage{ifxetex}
\pgfkeys{
  /eolang/.cd,
  tmpdir/.store in=\eolang@tmpdir,
  tmpdir/.default=_eolang\ifxetex-xe\else\ifluatex-lua\fi\fi,
  nocomments/.store in=\eolang@nocomments,
  anonymous/.store in=\eolang@anonymous,
  noshell/.store in=\eolang@noshell,
  tmpdir
}
\ProcessPgfPackageOptions{/eolang}

\makeatletter
\ifdefined\eolang@noshell\else\RequirePackage{shellesc}\fi
\IfFileExists
  {\eolang@tmpdir/\jobname}
  {\message{eolang: Temporary directory "\eolang@tmpdir/\jobname"
    already exists^^J}}
  {
    \ifdefined\eolang@noshell
      \message{eolang: Temporary directory "\eolang@tmpdir/\jobname"
        is not created, because of the "noshell" package option,
        most probably the compilation will fail later^^J}
    \else
      \ifnum\ShellEscapeStatus=1
        \iexec[null]{mkdir -p "\eolang@tmpdir/\jobname"}
      \else
        \message{eolang: Temporary directory "\eolang@tmpdir/\jobname"
          is not created, because -shell-escape is not set, and
          it doesn't exist, most probably the compilation
          will fail later^^J}
      \fi
    \fi
  }
\makeatother

\makeatletter\newcounter{eolang@lineno}\makeatother

\RequirePackage{pdftexcmds}
\makeatletter
\newcommand\eolang@mdfive[1]{\pdf@filemdfivesum{#1}}
\makeatother

\makeatletter
\ifdefined\eolang@noshell
  \message{eolang: Perl script is not going to be created,
  at "\eolang@tmpdir/\jobname-phi.pl" because of the "noshell"
  package option^^J}
\else
\openin 15=\eolang@tmpdir/\jobname-phi.pl
\ifeof 15
\message{eolang: Perl script is going to be created,
  because it is absent at "\eolang@tmpdir/\jobname-phi.pl",
  but if -shell-escape is not set, the compilation will
  most likely fail now^^J}
\begin{VerbatimOut}{\eolang@tmpdir/\jobname-phi.pl}
$macro = $ARGV[0];
open(my $fh, '<', $ARGV[1]);
my $tex; { local $/; $tex = <$fh>; }
print "% This file is auto-generated by 0.0.0\n";
print '% There are ', length($tex),
  ' chars in the input: ', $ARGV[1], "\n";
print '% ---', "\n";
if (index($tex, "\t") > 0) {
  print "TABS are prohibited!";
  exit 1;
}
my @lines = split (/\n/g, $tex);
foreach my $t (@lines) {
  print '% ', $t, "\n";
}
print '% ---', "\n";
$tex =~ s/(?<!\\)%.*\n/\n/g;
$tex =~ s/^\s+|\s+$//g;
my $splitting = $tex =~ /^\\begin\{split\}/;
if ($splitting) {
  print '% The manual splitting mode is ON since \begin{split} started the text' . "\n";
}
my $indents = $tex =~ /\n +/g;
my $gathered = (0 == $indents);
if ($gathered) {
  if ($splitting) {
    print '% The "gathered" is NOT used because of manual splitting' . "\n";
    $gathered = 0;
  } else {
    print '% The "gathered" is used since all lines are left-aligned' . "\n";
  }
} else {
  print '% The "gathered" is NOT used because ' .
    $indents . " lines are indented\n";
}
my $align = 0;
print '% The "align" is NOT used by default' . "\n";
if (index($tex, '&&') >= 0) {
  $macro =~ s/equation/align/g;
  $align = 1;
  print '% The "align" is used because of && seen in the text' . "\n";
}
if ($macro ne 'phiq') {
  if (not $splitting) {
    $tex =~ s/\\\\\n/\n\n/g;
    $tex =~ s/\\\n\s*//g;
  }
  $tex =~ s/\n*(\\label\{[^\}]+\})\n*/\1/g;
  $tex =~ s/\n{3,}/\n\n/g;
}
my @texts = ();
sub trep {
  my ($s) = @_;
  my $open = 0;
  my $p = 0;
  for (; $p < length($s); $p++) {
    $c = substr($s, $p, 1);
    if ($c eq '}') {
      if ($open eq 0) {
        last;
      }
      $open--;
    }
    if ($c eq '{') {
      $open++;
    }
  }
  push(@texts, substr($s, 0, $p));
  return '{TEXT' . (0+@texts - 1) . '}' . substr($s, $p + 1);
}
$tex =~ s/\\text\{(.+)/trep("$1")/ge;
if (not $splitting) {
  $tex =~ s/(?<![{&])&(?![&}])/\\sigma{}/g;
}
$tex =~ s/([^\\{a-z0-9]|^)QQ(?![a-z0-9])/\1\\dot{\\Phi{}}/g;
$tex =~ s/([^\\{a-z0-9]|^)Q(?![a-z0-9])/\1\\Phi{}/g;
$tex =~ s/([^\\{a-z0-9]|^)D>/\1\\Delta{}..>/g;
$tex =~ s/([^\\{a-z0-9]|^)L>/\1\\lambda{}..>/g;
$tex =~ s/"([^"]+)"/|"\1"|/g;
$tex =~ s/(^|(?<=[\s)(\]\[,.>\/]))([a-zA-Z][a-z0-9]+)(?=[\s)(\]\[,.-]|$)/|\2|/g;
$tex =~ s/([^_^]|^)([0-9]+|\*)\/(\\?[a-z]+|\|[a-z]+\|)
  (->|\.\.>|~>|:=|!->)/\1\\alpha_{\2}\\vert{}\3\\space{}\4/xg;
$tex =~ s/([^_^]|^)([0-9]+|\*)
  (->|\.\.>|~>|:=|!->)/\1\\alpha_{\2}\\space{}\3/xg;
if ($macro ne 'phiq') {
  if (not $splitting) {
    $tex =~ s/\\begin\{split\}\n/\\begin{split}&/g;
    $tex =~ s/\n\s*\\end\{split\}/\\end{split}/g;
    $tex =~ s/\n\n/\\\\&/g;
    $tex =~ s/\n/\\phiEOL{}\n&/g;
    $tex =~ s/\\\\$//g;
    $tex =~ s/\\\\/\\\\\n/g;
    $tex =~ s/([^&\s])\s{2}([^\s])/\1 \2/g;
    $tex =~ s/\s{2}/ \\quad{}/g;
    $tex = '&' . $tex;
  }
  my $lead = '[^\s]+\s(?:->|:=|=|==)\s';
  my @leads = $tex =~ /&${lead}/g;
  my @eols = $tex =~ /&/g;
  if (0+@leads == 0+@eols && 0+@eols > 1) {
    $tex =~ s/&(${lead})/\1&~/g;
    $gathered = 0;
    print '% The "gathered" is NOT used because all ' .
      (0+@eols) . ' lines are ' . (0+@leads) . " leads\n";
  }
}
if ($macro ne 'phiq') {
  sub strip_tabs {
    my ($env, $tex) = @_;
    $tex =~ s/&//g;
    return "\\begin{$env}" . $tex . "\\end{$env}";
  }
  foreach my $e (('matrix', 'cases')) {
    $tex =~ s/\\begin\{(\Q$e\E\*?)\}(.+)\\end\{\Q$e\E\*?\}/strip_tabs($1, $2)/sge;
  }
}
$tex =~ s/\$/\\xi{}/g;
$tex =~ s/(?<!\{)\^(?!\{)/\\rho{}/g;
$tex =~ s/\[\[/\\llbracket\\mathbin{}/g;
$tex =~ s/\]\]/\\mathbin{}\\rrbracket{}/g;
$tex =~ s/([\s,>(])([0-9A-F]{2}(?:-[0-9A-F]{2})+|
  [0-9]+(?:\.[0-9]+)?)(?!\{)/\1|\2|/xg;
$tex =~ s/TRUE/|TRUE|/g;
$tex =~ s/FALSE/|FALSE|/g;
$tex =~ s/\?/\\varnothing{}/g;
$tex =~ s/@/\\varphi{}/g;
$tex =~ s/-([a-z]+)>/\\mathrel{\\phiSlot{\1}}/g;
$tex =~ s/!->/\\mathbin{\\phiConst}/g;
$tex =~ s/->/\\mathbin{\\mapsto}/g;
$tex =~ s/~>/\\mathbin{\\phiWave}/g;
$tex =~ s/:=/\\mathrel{\\vDash}/g;
$tex =~ s/==/\\mathrel{\\equiv}/g;
$tex =~ s/\.\.>/\\mathbin{\\phiDotted}/g;
$tex =~ s/<</\\langle/g;
$tex =~ s/>>/\\rangle/g;
$tex =~ s/\|{2,}/|/g;
$tex =~ s/\|([^\|]+)\|/\\textnormal{\\texttt{\1}}{}/g;
$tex =~ s/\{TEXT(\d+)\}/'\\text{' . @texts[$1] . '}';/ge;
if ($macro eq 'phiq') {
  print '\(' if ($tex ne '');
} else {
  print '\begin{', $macro, "}\n";
  if (not($align)) {
    if ($gathered) {
      print '\begin{gathered}' . "\n";
    } elsif (not $splitting) {
      print '\begin{split}' . "\n";
    }
  }
}
if ($gathered and not($align)) {
  $tex =~ s/^&//g;
  $tex =~ s/\n&/\n/g;
}
print $tex;
if ($macro eq 'phiq') {
  print '\)' if ($tex ne '');
} else {
  if (not($align)) {
    if ($gathered) {
      print "\n" . '\end{gathered}';
    } elsif (not $splitting) {
      print "\n" . '\end{split}';
    }
  }
  print "\n" . '\end{' . $macro . '}';
}
print '\endinput';
\end{VerbatimOut}
\message{eolang: File with Perl script
  '\eolang@tmpdir/\jobname-phi.pl' saved^^J}
\else
  \message{eolang: Perl script already exists at
    "\eolang@tmpdir/\jobname-phi.pl"^^J}
\fi
\closein 15
\fi
\makeatother

\makeatletter
\newcommand\phiSaveTo[1]{\def\eolang@phiSaveTo{#1}}
\makeatother

\makeatletter
\newcommand\eolang@ifabsent[2]{%
  \IfFileExists
    {#1}
    {%
      \message{eolang: File "#1" already exists ^^J}%
      \input{#1}}
    {%
      \ifdefined\eolang@noshell%
        \message{eolang: Shell processing is disabled^^J}%
      \else%
        \ifnum\ShellEscapeStatus=1\else%
          \message{eolang: The -shell-escape command line
          option is not provided, most probably compilation
          will fail now:^^J}%
        \fi%
        #2%
      \fi%
    }%
}
\makeatother

\makeatletter\newcommand\eolang@process[1]{
  \def\hash{\eolang@mdfive
    {\eolang@tmpdir/\jobname/phiquation.tex}-\the\inputlineno}%
  \eolang@ifabsent
    {\eolang@tmpdir/\jobname/\hash-phiquation-post.tex}
    {%
      \iexec[null]{cp "\eolang@tmpdir/\jobname/phiquation.tex"
        "\eolang@tmpdir/\jobname/\hash-phiquation.tex"}%
      \message{Start parsing 'phi' at line no. \the\inputlineno^^J}
      \iexec[trace,stdout=\eolang@tmpdir/\jobname/\hash-phiquation-post.tex]{
        perl "\eolang@tmpdir/\jobname-phi.pl"
        '#1'
        "\eolang@tmpdir/\jobname/\hash-phiquation.tex"
        \ifdefined\eolang@nocomments | perl -pe 's/\%.*(\\n|$)//g'\fi
        \ifdefined\eolang@phiSaveTo > \eolang@phiSaveTo\fi}%
    }%
  \setcounter{FancyVerbLine}{\value{eolang@lineno}}%
  \def\eolang@phiSaveTo{\relax}%
}
\newenvironment{phiquation*}%
{\catcode`\|=12 \VerbatimEnvironment%
\setcounter{eolang@lineno}{\value{FancyVerbLine}}%
\begin{VerbatimOut}
  {\eolang@tmpdir/\jobname/phiquation.tex}}
{\end{VerbatimOut}\eolang@process{equation*}}
\newenvironment{phiquation}%
{\catcode`\|=12 \VerbatimEnvironment%
\setcounter{eolang@lineno}{\value{FancyVerbLine}}%
\begin{VerbatimOut}
  {\eolang@tmpdir/\jobname/phiquation.tex}}
{\end{VerbatimOut}\eolang@process{equation}}
\makeatother

\RequirePackage{xstring}
\makeatletter\newcommand\phiq[1]{%
  \StrSubstitute{\detokenize{#1}}{'}{'"'"'}[\clean]%
  \def\hash{\pdf@mdfivesum{\clean}-\the\inputlineno}%
  \ifdefined\eolang@nodollar\else\catcode`\$=3 \fi%
  \eolang@ifabsent
    {\eolang@tmpdir/\jobname/\hash-phiq-post.tex}
    {%
      \iexec[log,trace,quiet,stdout=\eolang@tmpdir/\jobname/phiq.tex]{
        /bin/echo '\clean'}%
      \iexec[quiet,null]{cp "\eolang@tmpdir/\jobname/phiq.tex"
        "\eolang@tmpdir/\jobname/\hash-phiq.tex"}%
      \iexec[trace,stdout=\eolang@tmpdir/\jobname/\hash-phiq-post.tex]{
        perl \eolang@tmpdir/\jobname-phi.pl 'phiq'
        "\eolang@tmpdir/\jobname/\hash-phiq.tex"
        \ifdefined\eolang@nocomments | perl -pe 's/\%.*(\\n|$)//g' \fi}%
      \message{eolang: Parsed `phiq' at line no. \the\inputlineno^^J}%
    }%
  \ifdefined\eolang@nodollar\else\catcode`\$\active\fi%
}\makeatother

\ifdefined\eolang@nodollar\else
  \begingroup
  \catcode`\$=\active
  \protected\gdef$#1${\phiq{#1}}
  \endgroup
  \AtBeginDocument{\catcode`\$=\active}
\fi

\makeatletter
\ifdefined\eolang@noshell
\message{eolang: Perl script is not going to be created
  at "\eolang@tmpdir/\jobname-sodg.pl", because of the
  "noshell" package option^^J}
\else
\openin 15=\eolang@tmpdir/\jobname-sodg.pl
\ifeof 15
\message{eolang: Perl script is going to be created,
  because it is absent at "\eolang@tmpdir/\jobname-sodg.pl",
  but if -shell-escape is not set, the compilation will
  most likely fail now^^J}
\begin{VerbatimOut}{\eolang@tmpdir/\jobname-sodg.pl}
sub num {
  my ($i) = @_;
  $i =~ s/(\+|-)\./\10./g;
  return $i;
}
sub fmt {
  my ($tex) = @_;
  $tex =~ s/\|([^\|]+)\|/\\textnormal{\\texttt{\1}}/g;
  return $tex;
}
sub toem {
  my ($cm) = @_;
  return $cm * 2.8;
}
sub vertex {
  my ($v) = @_;
  if (index($v, 'v0') == 0) {
    return '\Phi';
  } else {
    $v =~ s/^v/v_{/g;
    $v =~ s/[^0-9]$//g;
    return $v . '}';
  }
}
sub tailor {
  my ($t, $m) = @_;
  $t =~ s/<([A-Z]?${m}[A-Z]?):([^>]+)>/\2/g;
  $t =~ s/<[A-Z]+:[^>]+>//g;
  return $t;
}
open(my $fh, '<', $ARGV[0]);
my $tex; { local $/; $tex = <$fh>; }
if (index($tex, "\t") > 0) {
  print "TABS are prohibited!";
  exit 1;
}
print '% This file is auto-generated', "\n%\n";
print '% --- there are ', length($tex),
  ' chars in the input (', $ARGV[0], "):\n";
foreach my $t (split (/\n/g, $tex)) {
  print '% ', $t, "\n";
}
print "% ---\n";
$tex =~ s/\\\\/\n/g;
$tex =~ s/\\\n//g;
$tex =~ s/(\\[a-zA-Z]+)\s+/\1/g;
$tex =~ s/\n{2,}/\n/g;
my @cmds = split(/\n/g, $tex);
print '% --- before processing:' . "\n";
foreach my $t (split (/\n/g, $tex)) {
  print '% ', $t, "\n";
}
print '% ---';
print ' (' . (0+@cmds) . " lines)\n";
print '\begin{phicture}', "\n";
for (my $c = 0; $c < 0+@cmds; $c++) {
  my $cmd = $cmds[$c];
  $cmd =~ s/^\s+//g;
  $cmd =~ s/(?<!\\)%.*//g;
  my ($head, $tail) = split(/ /, $cmd, 2);
  my %opts = {};
  my ($body, $style) = split(/style:/, $tail, 2);
  $opts{'style'} = $style;
  $tail = $body;
  foreach my $p (split(/ /, $tail)) {
    my ($q, $t) = split(/:/, $p);
    $opts{$q} = $t;
  }
  if (index($head, '\\') == 0) {
    print $cmd;
  } elsif (index($head, '->') >= 0) {
    my $draw = '\draw[';
    if (exists $opts{'pi'}) {
      $draw = $draw . '<MB:phi-pi><F:draw=none>';
      if (not exists $opts{'a'}) {
        $opts{'a'} = '\pi';
      }
    }
    if (exists $opts{'rho'} and not(exists $opts{'bend'})) {
      $draw = $draw . '<MB:,phi-rho>';
    }
    $draw = $draw . ',' . $opts{'style'} . ']';
    my ($from, $to) = split (/->/, $head);
    $draw = $draw . " (${from}) ";
    if (exists $opts{'bend'}) {
      $draw = $draw . 'edge [<F:draw=none><MF:,bend right=' .
        num($opts{'bend'}) . '>';
      if (exists $opts{'rho'}) {
        $draw = $draw . '<MB:,phi-rho>';
      }
      $draw = $draw . ']';
    } else {
      $draw = $draw . '--';
    }
    if (exists $opts{'a'}) {
      my $a = $opts{'a'};
      if (index($a, '$') == -1) {
        $a = '$' . fmt($a) . '$';
      } else {
        $a = fmt($a);
      }
      $draw = $draw . '<MB: node [phi-attr] {' . $a . '}>';
    }
    if (exists $opts{'break'}) {
      $draw = $draw . '<F: coordinate [pos=' .
        ($opts{'break'} / 100) . '] (break)>';
    }
    $draw = $draw . " (<MF:${to}><B:break-v>)";
    if (exists $opts{'break'}) {
      print tailor($draw, 'F') . ";\n";
      print '  \node[outer sep=' . toem(0.1) . 'em,inner sep=0em] ' .
        'at (break) (break-v) {$' . vertex($to) .
        '$};' . "\n";
      print '  ' . tailor($draw, 'B');
    } else {
      print tailor($draw, 'M');
    }
  } elsif (index($head, '=>') >= 0) {
    my ($from, $to) = split (/=+>/, $head);
    my $size = () = $head =~ /=/g;
    if ($from eq '') {
      print '\node [phi-arrow, left=' . toem($size * 0.6) . 'em of ' .
        $to . '.center]';
    } elsif ($to eq '') {
      print '\node [phi-arrow, right=' . toem($size * 0.6) . 'em of ' .
        $from . '.center]';
    } else {
      print '\node [phi-arrow] at ($(' .
        $from . ')!0.5!(' . $to . ')$)';
    }
    print '{}';
  } elsif (index($head, '!') >= 0) {
    my ($v, $marker) = split (/!+/, $head);
    my $size = () = $head =~ /!/g;
    print '\node [phi-marker, left=' .
      toem($size * 0.6) . 'em of ' .
      $v . '.center]{' . fmt($marker) . '}';
  } elsif (index($head, '+') >= 0) {
    my ($v, $suffix) = split (/\+/, $head);
    my @friends = ($v);
    foreach my $c (@cmds) {
      $e = $c;
      $e =~ s/^\s+//g;
      my $h = $e;
      $h = substr($e, 0, index($e, ' ')) if index($e, ' ') >= 0;
      foreach my $f (@friends) {
        my $add = '';
        if (index($h, $f . '->') >= 0) {
          $add = substr($h, index($h, '->') + 2);
        }
        if ($h =~ /->\Q${f}\E$/) {
          $add = substr($h, 0, index($h, '->'));
        }
        if (index($e, ' xy:' . $f . ',') >= 0) {
          $add = $h;
        }
        if (index($add, '+') == -1
          and $add ne ''
          and not(grep(/^\Q${add}\E$/, @friends))) {
          push(@friends, $add);
        }
      }
    }
    my @extra = ();
    foreach my $e (@cmds) {
      $m = $e;
      if ($m =~ /^\s*\Q${v}\E\s/) {
        next;
      }
      if ($m =~ /^\s*[^\s]+\+/ and not($m =~ /^\s*\Q${head}\E\s/)) {
        next;
      }
      foreach my $f (@friends) {
        my $h = $f;
        $h =~ s/[a-z]$//g;
        if ($m =~ s/^(\s*)\Q${f}\E\+\Q${suffix}\E\s?/\1${h}${suffix} /g) {
          last;
        }
        $m =~ s/^(\s*)\Q${f}\E\s/\1${h}${suffix} /g;
        $m =~ s/^(\s*)\Q${f}\E->/\1${h}${suffix}->/g;
        $m =~ s/\sxy:\Q${f}\E,/ xy:${h}${suffix},/g;
        $m =~ s/->\Q${f}\E\s/->${h}${suffix} /g;
      }
      if ($m ne $e) {
        push(@extra, ' ' . $m);
      }
    }
    splice(@extra, 0, 0, @extra[-1]);
    splice(@extra, -1, 1);
    splice(@extra, 0, 0, '% clone of ' . $v . ' (' . $head .
      '), friends: [' . join(', ', @friends) . '] in ' .
      (0+@cmds) . ' lines');
    splice(@cmds, $c, 1, @extra);
    print '% cloned ' . $v . ' at line no.' . $c .
      ' (+' . (0+@extra) . ' lines -> ' .
      (0+@cmds) . ' lines total)';
  } elsif ($head =~ /^v[0-9]+[a-z]?$/) {
    print '\node[';
    if (exists $opts{'xy'}) {
      my ($v, $right, $down) = split(/,/, $opts{'xy'});
      my $loc = '';
      if ($down > 0) {
        $loc = 'below ';
      } elsif ($down < 0) {
        $loc = 'above ';
      }
      if ($right > 0) {
        $loc = $loc . 'right';
      } elsif ($right < 0) {
        $loc = $loc . 'left';
      }
      print ',' . $loc . '=';
      print toem(abs(num($down))) . 'em and ' .
        toem(abs(num($right))) . 'em of ' . $v . '.center';
    }
    if (exists $opts{'data'}) {
      print ',phi-data';
      if ($opts{'data'} ne '') {
        my $d = $opts{'data'};
        if (index($d, '|') == -1) {
          $d = '$\Delta\phiDotted\text{' .
            '\textnormal{\texttt{' . fmt($d) . '}}}$';
        } else {
          $d = fmt($d);
        }
        $opts{'box'} = $d;
      }
    } elsif (exists $opts{'atom'}) {
      print ',phi-atom';
      if ($opts{'atom'} ne '') {
        my $a = $opts{'atom'};
        if (index($a, '$') == -1) {
          $a = '$\lambda\phiDotted{}' . fmt($a) . '$';
        } else {
          $a = fmt($a);
        }
        $opts{'box'} = $a;
      }
    } else {
      print ',phi-object';
    }
    if (exists $opts{'edgeless'}) {
      print ',draw=none';
    }
    print ',' . $opts{'style'} . ']';
    print ' (' . $head . ')';
    print ' {';
    if (exists $opts{'tag'}) {
      my $t = $opts{'tag'};
      if (index($t, '$') == -1) {
        $t = '$' . $t . '$';
      } else {
        $t = fmt($t);
      }
      print $t;
    } else {
      print '$' . vertex($head) . '$';
    }
    print '}';
    if (exists $opts{'box'}) {
      print ' node[phi-box] at (';
      print $head, '.south east) {';
      print $opts{'box'}, '}';
    }
  }
  print ";\n";
}
print '\end{phicture}%', "\n";
print "% --- after processing:\n%";
foreach my $c (@cmds) {
  print '% ', $c, "\n";
}
print '% --- (' . (0+@cmds) . " lines)\n";
print '\endinput';
\end{VerbatimOut}
\message{eolang: File with Perl script
  '\eolang@tmpdir/\jobname-sodg.pl' saved^^J}
\else
  \message{eolang: Perl script already exists at
    "\eolang@tmpdir/\jobname-sodg.pl"^^J}
\fi
\closein 15
\fi
\makeatother

\setcounter{FancyVerbLine}{0}

\RequirePackage{tikz}
  \usetikzlibrary{arrows}
  \usetikzlibrary{shapes}
  \usetikzlibrary{decorations}
  \usetikzlibrary{decorations.pathmorphing}
  \usetikzlibrary{decorations.pathreplacing}
  \usetikzlibrary{positioning}
  \usetikzlibrary{calc}
  \usetikzlibrary{math}
  \usetikzlibrary{arrows.meta}

\newenvironment{phicture}%
  {\noindent\begin{tikzpicture}[
    ->,>=stealth',node distance=0,line width=.08em,
    pics/parallel arrow/.style={
      code={\draw[-latex,phi-rho] (##1) -- (-##1);}}]}%
  {\end{tikzpicture}}
\tikzstyle{phi-arrow} = [fill=white!80!black, single arrow,
  minimum height=0.05em, minimum width=0.05em,
  single arrow head extend=2mm]
\tikzstyle{phi-marker} = [inner sep=0pt, minimum height=1.4em,
  minimum width=1.4em, font={\small\color{white}\ttfamily},
  fill=gray]
\tikzstyle{phi-thing} = [inner sep=0pt,minimum height=2.4em,
  draw,font={\small}]
\tikzstyle{phi-object} = [phi-thing,circle]
\tikzstyle{phi-data} = [phi-thing,regular polygon,
  regular polygon sides=8]
\tikzstyle{phi-empty} = [phi-object]
\tikzset{%
  phi-rho/.style={
    postaction={%
      decoration={
        show path construction,
        curveto code={
          \tikzmath{
            coordinate \I, \F, \v;
            \I = (\tikzinputsegmentfirst);
            \F = (\tikzinputsegmentlast);
            \v = ($(\I) -(\F)$);
            real \d, \a, \r, \t;
            \d = 0.8;
            \t = atan2(\vy, \vx);
            if \vx<0 then { \a = 90; } else { \a = -90; };
            {
              \draw[arrows={-latex}, decorate,
              decoration={%
                snake, amplitude=.4mm,
                segment length=2mm,
                post length=1mm
              }]
              ($(\F)!.5!(\I) +(\t: -\d em) +(\t +\a: 1ex)$)
              -- ++(\t: 2*\d em);
            };
          }
        },
        lineto code={
          \tikzmath{
            coordinate \I, \F, \v;
            \I = (\tikzinputsegmentfirst);
            \F = (\tikzinputsegmentlast);
            \v = ($(\I) -(\F)$);
            real \d, \a, \r, \t;
            \d = 0.8;
            \t = atan2(\vy, \vx);
            if \vx<0 then { \a = 90; } else { \a = -90; };
            {
              \draw[arrows={-latex}, decorate,
              decoration={%
                snake, amplitude=.4mm,
                segment length=2mm,
                post length=1mm}]
              ($(\F)!.5!(\I) +(\t: -\d em) +(\t +\a: 1ex)$)
              -- ++(\t: 2*\d em);
            };
          }
        }
      },
      decorate
    }
  }
}
\tikzstyle{phi-pi} = [draw,dotted]
\tikzstyle{phi-atom} = [phi-object,double]
\tikzstyle{phi-box} = [xshift=-5pt,yshift=3pt,draw,fill=white,
  rectangle,line width=.04em,minimum width=1.2em,anchor=north west,
  font={\scriptsize}]
\tikzstyle{phi-attr} = [midway,sloped,inner sep=0pt,
  above=2pt,sloped/.append style={transform shape},
  font={\scriptsize},color=black]

\makeatletter
\newcommand\sodgSaveTo[1]{\def\eolang@sodgSaveTo{#1}}
\makeatother

\makeatletter\newenvironment{sodg}%
{\catcode`\|=12 \VerbatimEnvironment%
\setcounter{eolang@lineno}{\value{FancyVerbLine}}%
\begin{VerbatimOut}
  {\eolang@tmpdir/\jobname/sodg.tex}}
{\end{VerbatimOut}%
  \def\hash{\eolang@mdfive
    {\eolang@tmpdir/\jobname/sodg.tex}-\the\inputlineno}%
  \catcode`\$=3 %
  \eolang@ifabsent
    {\eolang@tmpdir/\jobname/\hash-sodg-post.tex}
    {%
      \iexec[null]{cp "\eolang@tmpdir/\jobname/sodg.tex"
        "\eolang@tmpdir/\jobname/\hash-sodg.tex"}%
      \message{eolang: Start parsing `sodg' at line no. \the\inputlineno^^J}
      \iexec[trace,stdout=\eolang@tmpdir/\jobname/\hash-sodg-post.tex]{
        perl "\eolang@tmpdir/\jobname-sodg.pl"
        "\eolang@tmpdir/\jobname/\hash-sodg.tex"
        \ifdefined\eolang@nocomments | perl -pe 's/\%.*(\\n|$)//g'\fi
        \ifdefined\eolang@sodgSaveTo > \eolang@sodgSaveTo\fi}%
    }
  \catcode`\$\active%
  \setcounter{FancyVerbLine}{\value{eolang@lineno}}%
  \def\eolang@sodgSaveTo{\relax}%
}\makeatother

\RequirePackage{hyperref}
\pdfstringdefDisableCommands{
  \def\({}%
  \def\){}%
  \def\alpha{alpha}%
  \def\varphi{phi}%
}
\makeatletter
\NewExpandableDocumentCommand{\eoAnon}{O{ANONYMIZED}m}{%
  \ifdefined\eolang@anonymous%
    \textcolor{orange}{#1}%
  \else%
    #2%
  \fi%
}\makeatother

\newcommand\eolang{%
  \eoAnon[XYZ]{{\sffamily EO}}}

\newcommand\phic{%
  \eoAnon[\(\alpha\)-cal\-cu\-lus]{\(\varphi\)-cal\-cu\-lus}}

\newcommand\xmir{%
  \eoAnon[XML\(^+\)]{XMIR}}

\newcommand\phiConst{%
  \mathrel{\hspace{.15em}}%
  \mapstochar\mathrel{\hspace{-.15em}}\mapsto}

\newcommand\phiWave{%
  \mapstochar\mathrel{\mspace{0.45mu}}\leadsto}

\newcommand\phiSlot[1]{%
  \xrightarrow{\text{\sffamily\scshape #1}}}

\makeatletter
\newcommand{\phiOset}[2]{%
  \mathrel{\mathop{#2}\limits^{
    \vbox to 0ex{\kern-2\ex@
    \hbox{$\scriptscriptstyle#1$}\vss}}}}
\newcommand{\phiUset}[2]{%
  \mathrel{\mathop{#2}\limits_{
    \vbox to 0ex{\kern-6.3\ex@
    \hbox{$\scriptscriptstyle#1$}\vss}}}}
\makeatother

\newcommand\phiMany[3]{%
  \phiOset{#3}{\phiUset{#2}{#1}}}

\newcommand\phiEOL{\\[-4pt]}

\RequirePackage{trimclip}
\RequirePackage{amsfonts}
\makeatletter
\newcommand{\phiDotted}{%
  \mapstochar\mathrel{\mathpalette\phiDotted@\relax}}
\newcommand{\phiDotted@}[2]{%
  \begingroup%
  \settowidth{\dimen\z@}{$\m@th#1\rightarrow$}%
  \settoheight{\dimen\tw@}{$\m@th#1\rightarrow$}%
  \sbox\z@{%
    \makebox[\dimen\z@][s]{%
      \clipbox{0 0 {0.4\width} 0}%
        {\resizebox{\dimen\z@}{\height}%
          {$\m@th#1\dashrightarrow$}}%
      \hss%
      \clipbox{{0.69\width} {-0.1\height} 0
        {-\height}}{$\m@th#1\rightarrow$}%
    }%
  }%
  \ht\z@=\dimen\tw@ \dp\z@=\z@%
  \box\z@%
  \endgroup%
}
\makeatother



\endinput
%%
%% End of file `eolang.sty'.
